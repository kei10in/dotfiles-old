This is python-tutorial-3.2.2.info, produced by makeinfo version 4.13
from python-tutorial-3.2.2.texi.

Generated by Sphinx 1.1.2.
INFO-DIR-SECTION Python v3 2 2
START-INFO-DIR-ENTRY
* Tutorial: (python-tutorial-3.2.2.info). start here
END-INFO-DIR-ENTRY

     Python 3.2.2, February 11, 2012

     Guido van Rossum\\Fred L. Drake, Jr., editor

     Copyright (C) 1990-2012, Python Software Foundation


File: python-tutorial-3.2.2.info,  Node: Top,  Next: Whetting Your Appetite,  Up: (dir)

The Python Tutorial
*******************

     Python 3.2.2, February 11, 2012

     Guido van Rossum\\Fred L. Drake, Jr., editor

     Copyright (C) 1990-2012, Python Software Foundation

     Release: 3.2

     Date: February 10, 2012

  Python is an easy to learn, powerful programming language. It has
efficient high-level data structures and a simple but effective
approach to object-oriented programming. Python's elegant syntax and
dynamic typing, together with its interpreted nature, make it an ideal
language for scripting and rapid application development in many areas
on most platforms.

  The Python interpreter and the extensive standard library are freely
available in source or binary form for all major platforms from the
Python Web site, <http://www.python.org/>, and may be freely
distributed. The same site also contains distributions of and pointers
to many free third party Python modules, programs and tools, and
additional documentation.

  The Python interpreter is easily extended with new functions and data
types implemented in C or C++ (or other languages callable from C).
Python is also suitable as an extension language for customizable
applications.

  This tutorial introduces the reader informally to the basic concepts
and features of the Python language and system. It helps to have a
Python interpreter handy for hands-on experience, but all examples are
self-contained, so the tutorial can be read off-line as well.

  For a description of standard objects and modules, see
_library-index_.  _reference-index_ gives a more formal definition of
the language.  To write extensions in C or C++, read _extending-index_
and _c-api-index_. There are also several books covering Python in
depth.

  This tutorial does not attempt to be comprehensive and cover every
single feature, or even every commonly used feature. Instead, it
introduces many of Python's most noteworthy features, and will give you
a good idea of the language's flavor and style. After reading it, you
will be able to read and write Python modules and programs, and you
will be ready to learn more about the various Python library modules
described in _library-index_.

  The _glossary_ is also worth going through.

* Menu:

* Whetting Your Appetite::
* Using the Python Interpreter::
* An Informal Introduction to Python::
* More Control Flow Tools::
* Data Structures::
* Modules::
* Input and Output::
* Errors and Exceptions::
* Classes::
* Brief Tour of the Standard Library::
* Brief Tour of the Standard Library: Brief Tour of the Standard Library -- Part II. Part II
* What Now?::
* Interactive Input Editing and History Substitution::
* Floating Point Arithmetic; Issues and Limitations: Floating Point Arithmetic Issues and Limitations.
* Index::


File: python-tutorial-3.2.2.info,  Node: Whetting Your Appetite,  Next: Using the Python Interpreter,  Prev: Top,  Up: Top

1 Whetting Your Appetite
************************

If you do much work on computers, eventually you find that there's some
task you'd like to automate.  For example, you may wish to perform a
search-and-replace over a large number of text files, or rename and
rearrange a bunch of photo files in a complicated way. Perhaps you'd
like to write a small custom database, or a specialized GUI
application, or a simple game.

  If you're a professional software developer, you may have to work
with several C/C++/Java libraries but find the usual
write/compile/test/re-compile cycle is too slow.  Perhaps you're
writing a test suite for such a library and find writing the testing
code a tedious task.  Or maybe you've written a program that could use
an extension language, and you don't want to design and implement a
whole new language for your application.

  Python is just the language for you.

  You could write a Unix shell script or Windows batch files for some
of these tasks, but shell scripts are best at moving around files and
changing text data, not well-suited for GUI applications or games. You
could write a C/C++/Java program, but it can take a lot of development
time to get even a first-draft program.  Python is simpler to use,
available on Windows, Mac OS X, and Unix operating systems, and will
help you get the job done more quickly.

  Python is simple to use, but it is a real programming language,
offering much more structure and support for large programs than shell
scripts or batch files can offer.  On the other hand, Python also
offers much more error checking than C, and, being a _very-high-level
language_, it has high-level data types built in, such as flexible
arrays and dictionaries.  Because of its more general data types Python
is applicable to a much larger problem domain than Awk or even Perl,
yet many things are at least as easy in Python as in those languages.

  Python allows you to split your program into modules that can be
reused in other Python programs.  It comes with a large collection of
standard modules that you can use as the basis of your programs -- or
as examples to start learning to program in Python.  Some of these
modules provide things like file I/O, system calls, sockets, and even
interfaces to graphical user interface toolkits like Tk.

  Python is an interpreted language, which can save you considerable
time during program development because no compilation and linking is
necessary.  The interpreter can be used interactively, which makes it
easy to experiment with features of the language, to write throw-away
programs, or to test functions during bottom-up program development. It
is also a handy desk calculator.

  Python enables programs to be written compactly and readably.
Programs written in Python are typically much shorter than equivalent
C,  C++, or Java programs, for several reasons:

   * the high-level data types allow you to express complex operations
     in a single statement;

   * statement grouping is done by indentation instead of beginning and
     ending brackets;

   * no variable or argument declarations are necessary.

  Python is _extensible_: if you know how to program in C it is easy to
add a new built-in function or module to the interpreter, either to
perform critical operations at maximum speed, or to link Python
programs to libraries that may only be available in binary form (such
as a vendor-specific graphics library).  Once you are really hooked,
you can link the Python interpreter into an application written in C
and use it as an extension or command language for that application.

  By the way, the language is named after the BBC show "Monty Python's
Flying Circus" and has nothing to do with reptiles.  Making references
to Monty Python skits in documentation is not only allowed, it is
encouraged!

  Now that you are all excited about Python, you'll want to examine it
in some more detail.  Since the best way to learn a language is to use
it, the tutorial invites you to play with the Python interpreter as you
read.

  In the next chapter, the mechanics of using the interpreter are
explained.  This is rather mundane information, but essential for
trying out the examples shown later.

  The rest of the tutorial introduces various features of the Python
language and system through examples, beginning with simple
expressions, statements and data types, through functions and modules,
and finally touching upon advanced concepts like exceptions and
user-defined classes.


File: python-tutorial-3.2.2.info,  Node: Using the Python Interpreter,  Next: An Informal Introduction to Python,  Prev: Whetting Your Appetite,  Up: Top

2 Using the Python Interpreter
******************************

* Menu:

* Invoking the Interpreter::
* The Interpreter and Its Environment::

Invoking the Interpreter

* Argument Passing::
* Interactive Mode::

The Interpreter and Its Environment

* Error Handling::
* Executable Python Scripts::
* Source Code Encoding::
* The Interactive Startup File::
* The Customization Modules::


File: python-tutorial-3.2.2.info,  Node: Invoking the Interpreter,  Next: The Interpreter and Its Environment,  Up: Using the Python Interpreter

2.1 Invoking the Interpreter
============================

The Python interpreter is usually installed as
`/usr/local/bin/python3.2' on those machines where it is available;
putting `/usr/local/bin' in your Unix shell's search path makes it
possible to start it by typing the command

    python3.2

to the shell. (1) Since the choice of the directory where the
interpreter lives is an installation option, other places are possible;
check with your local Python guru or system administrator.  (E.g.,
`/usr/local/python' is a popular alternative location.)

  On Windows machines, the Python installation is usually placed in
`C:\Python32', though you can change this when you're running the
installer.  To add this directory to your path,  you can type the
following command into the command prompt in a DOS box:

    set path=%path%;C:\python32

Typing an end-of-file character (`Control-D' on Unix, `Control-Z' on
Windows) at the primary prompt causes the interpreter to exit with a
zero exit status.  If that doesn't work, you can exit the interpreter
by typing the following command: `quit()'.

  The interpreter's line-editing features usually aren't very
sophisticated.  On Unix, whoever installed the interpreter may have
enabled support for the GNU readline library, which adds more elaborate
interactive editing and history features. Perhaps the quickest check to
see whether command line editing is supported is typing Control-P to
the first Python prompt you get.  If it beeps, you have command line
editing; see Appendix *note Interactive Input Editing and History
Substitution: b. for an introduction to the keys.  If nothing appears
to happen, or if `^P' is echoed, command line editing isn't available;
you'll only be able to use backspace to remove characters from the
current line.

  The interpreter operates somewhat like the Unix shell: when called
with standard input connected to a tty device, it reads and executes
commands interactively; when called with a file name argument or with a
file as standard input, it reads and executes a _script_ from that file.

  A second way of starting the interpreter is `python -c command [arg]
...', which executes the statement(s) in _command_, analogous to the
shell's `-c' option.  Since Python statements often contain spaces or
other characters that are special to the shell, it is usually advised
to quote _command_ in its entirety with single quotes.

  Some Python modules are also useful as scripts.  These can be invoked
using `python -m module [arg] ...', which executes the source file for
_module_ as if you had spelled out its full name on the command line.

  When a script file is used, it is sometimes useful to be able to run
the script and enter interactive mode afterwards.  This can be done by
passing `-i' before the script.  (This does not work if the script is
read from standard input, for the same reason as explained in the
previous paragraph.)

* Menu:

* Argument Passing::
* Interactive Mode::

  ---------- Footnotes ----------

  (1) On Unix, the Python 3.x interpreter is by default not installed
with the executable named `python', so that it does not conflict with a
simultaneously installed Python 2.x executable.


File: python-tutorial-3.2.2.info,  Node: Argument Passing,  Next: Interactive Mode,  Up: Invoking the Interpreter

2.1.1 Argument Passing
----------------------

When known to the interpreter, the script name and additional arguments
thereafter are turned into a list of strings and assigned to the `argv'
variable in the `sys' module.  You can access this list by executing
`import sys'.  The length of the list is at least one; when no script
and no arguments are given, `sys.argv[0]' is an empty string.  When the
script name is given as `'-'' (meaning  standard input), `sys.argv[0]'
is set to `'-''.  When `-c' _command_ is used, `sys.argv[0]' is set to
`'-c''.  When `-m' _module_ is used, `sys.argv[0]'  is set to the full
name of the located module.  Options found after  `-c' _command_ or `-m'
_module_ are not consumed  by the Python interpreter's option
processing but left in `sys.argv' for  the command or module to handle.


File: python-tutorial-3.2.2.info,  Node: Interactive Mode,  Prev: Argument Passing,  Up: Invoking the Interpreter

2.1.2 Interactive Mode
----------------------

When commands are read from a tty, the interpreter is said to be in
_interactive mode_.  In this mode it prompts for the next command with
the _primary prompt_, usually three greater-than signs (`>>>'); for
continuation lines it prompts with the _secondary prompt_, by default
three dots (`...'). The interpreter prints a welcome message stating
its version number and a copyright notice before printing the first
prompt:

    $ python3.2
    Python 3.2 (py3k, Sep 12 2007, 12:21:02)
    [GCC 3.4.6 20060404 (Red Hat 3.4.6-8)] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>>


  Continuation lines are needed when entering a multi-line construct.
As an example, take a look at this `if' statement:

    >>> the_world_is_flat = 1
    >>> if the_world_is_flat:
    ...     print("Be careful not to fall off!")
    ...
    Be careful not to fall off!



File: python-tutorial-3.2.2.info,  Node: The Interpreter and Its Environment,  Prev: Invoking the Interpreter,  Up: Using the Python Interpreter

2.2 The Interpreter and Its Environment
=======================================

* Menu:

* Error Handling::
* Executable Python Scripts::
* Source Code Encoding::
* The Interactive Startup File::
* The Customization Modules::


File: python-tutorial-3.2.2.info,  Node: Error Handling,  Next: Executable Python Scripts,  Up: The Interpreter and Its Environment

2.2.1 Error Handling
--------------------

When an error occurs, the interpreter prints an error message and a
stack trace.  In interactive mode, it then returns to the primary
prompt; when input came from a file, it exits with a nonzero exit
status after printing the stack trace.  (Exceptions handled by an
`except' clause in a `try' statement are not errors in this context.)
Some errors are unconditionally fatal and cause an exit with a nonzero
exit; this applies to internal inconsistencies and some cases of
running out of memory.  All error messages are written to the standard
error stream; normal output from executed commands is written to
standard output.

  Typing the interrupt character (usually Control-C or DEL) to the
primary or secondary prompt cancels the input and returns to the
primary prompt. (1) Typing an interrupt while a command is executing
raises the `KeyboardInterrupt' exception, which may be handled by a
`try' statement.

  ---------- Footnotes ----------

  (1) A problem with the GNU Readline package may prevent this.


File: python-tutorial-3.2.2.info,  Node: Executable Python Scripts,  Next: Source Code Encoding,  Prev: Error Handling,  Up: The Interpreter and Its Environment

2.2.2 Executable Python Scripts
-------------------------------

On BSD'ish Unix systems, Python scripts can be made directly
executable, like shell scripts, by putting the line

    #! /usr/bin/env python3.2

(assuming that the interpreter is on the user's `PATH') at the beginning
of the script and giving the file an executable mode.  The `#!' must be
the first two characters of the file.  On some platforms, this first
line must end with a Unix-style line ending (`'\n''), not a Windows
(`'\r\n'') line ending.  Note that the hash, or pound, character,
`'#'', is used to start a comment in Python.

  The script can be given an executable mode, or permission, using the
*chmod* command:

    $ chmod +x myscript.py

On Windows systems, there is no notion of an "executable mode".  The
Python installer automatically associates `.py' files with `python.exe'
so that a double-click on a Python file will run it as a script.  The
extension can also be `.pyw', in that case, the console window that
normally appears is suppressed.


File: python-tutorial-3.2.2.info,  Node: Source Code Encoding,  Next: The Interactive Startup File,  Prev: Executable Python Scripts,  Up: The Interpreter and Its Environment

2.2.3 Source Code Encoding
--------------------------

By default, Python source files are treated as encoded in UTF-8.  In
that encoding, characters of most languages in the world can be used
simultaneously in string literals, identifiers and comments -- although
the standard library only uses ASCII characters for identifiers, a
convention that any portable code should follow.  To display all these
characters properly, your editor must recognize that the file is UTF-8,
and it must use a font that supports all the characters in the file.

  It is also possible to specify a different encoding for source files.
In order to do this, put one more special comment line right after the
`#!' line to define the source file encoding:

    # -*- coding: encoding -*-

With that declaration, everything in the source file will be treated as
having the encoding _encoding_ instead of UTF-8.  The list of possible
encodings can be found in the Python Library Reference, in the section
on `codecs'.

  For example, if your editor of choice does not support UTF-8 encoded
files and insists on using some other encoding, say Windows-1252, you
can write:

    # -*- coding: cp-1252 -*-

and still use all characters in the Windows-1252 character set in the
source files.  The special encoding comment must be in the _first or
second_ line within the file.


File: python-tutorial-3.2.2.info,  Node: The Interactive Startup File,  Next: The Customization Modules,  Prev: Source Code Encoding,  Up: The Interpreter and Its Environment

2.2.4 The Interactive Startup File
----------------------------------

When you use Python interactively, it is frequently handy to have some
standard commands executed every time the interpreter is started.  You
can do this by setting an environment variable named `PYTHONSTARTUP' to
the name of a file containing your start-up commands.  This is similar
to the `.profile' feature of the Unix shells.

  This file is only read in interactive sessions, not when Python reads
commands from a script, and not when `/dev/tty' is given as the
explicit source of commands (which otherwise behaves like an
interactive session).  It is executed in the same namespace where
interactive commands are executed, so that objects that it defines or
imports can be used without qualification in the interactive session.
You can also change the prompts `sys.ps1' and `sys.ps2' in this file.

  If you want to read an additional start-up file from the current
directory, you can program this in the global start-up file using code
like `if os.path.isfile('.pythonrc.py'):
exec(open('.pythonrc.py').read())'.  If you want to use the startup
file in a script, you must do this explicitly in the script:

    import os
    filename = os.environ.get('PYTHONSTARTUP')
    if filename and os.path.isfile(filename):
        exec(open(filename).read())



File: python-tutorial-3.2.2.info,  Node: The Customization Modules,  Prev: The Interactive Startup File,  Up: The Interpreter and Its Environment

2.2.5 The Customization Modules
-------------------------------

Python provides two hooks to let you customize it: `sitecustomize' and
`usercustomize'.  To see how it works, you need first to find the
location of your user site-packages directory.  Start Python and run
this code:

    >>> import site
    >>> site.getusersitepackages()
    '/home/user/.local/lib/python3.2/site-packages'

Now you can create a file named `usercustomize.py' in that directory and
put anything you want in it.  It will affect every invocation of
Python, unless it is started with the `-s' option to disable the
automatic import.

  `sitecustomize' works in the same way, but is typically created by an
administrator of the computer in the global site-packages directory,
and is imported before `usercustomize'.  See the documentation of the
`site' module for more details.


File: python-tutorial-3.2.2.info,  Node: An Informal Introduction to Python,  Next: More Control Flow Tools,  Prev: Using the Python Interpreter,  Up: Top

3 An Informal Introduction to Python
************************************

In the following examples, input and output are distinguished by the
presence or absence of prompts (`>>>' and `...'): to repeat the
example, you must type everything after the prompt, when the prompt
appears; lines that do not begin with a prompt are output from the
interpreter. Note that a secondary prompt on a line by itself in an
example means you must type a blank line; this is used to end a
multi-line command.

  Many of the examples in this manual, even those entered at the
interactive prompt, include comments.  Comments in Python start with
the hash character, `#', and extend to the end of the physical line.  A
comment may appear at the start of a line or following whitespace or
code, but not within a string literal.  A hash character within a
string literal is just a hash character.  Since comments are to clarify
code and are not interpreted by Python, they may be omitted when typing
in examples.

  Some examples:

    # this is the first comment
    SPAM = 1                 # and this is the second comment
                             # ... and now a third!
    STRING = "# This is not a comment."


* Menu:

* Using Python as a Calculator::
* First Steps Towards Programming::

Using Python as a Calculator

* Numbers::
* Strings::
* About Unicode::
* Lists::


File: python-tutorial-3.2.2.info,  Node: Using Python as a Calculator,  Next: First Steps Towards Programming,  Up: An Informal Introduction to Python

3.1 Using Python as a Calculator
================================

Let's try some simple Python commands.  Start the interpreter and wait
for the primary prompt, `>>>'.  (It shouldn't take long.)

* Menu:

* Numbers::
* Strings::
* About Unicode::
* Lists::


File: python-tutorial-3.2.2.info,  Node: Numbers,  Next: Strings,  Up: Using Python as a Calculator

3.1.1 Numbers
-------------

The interpreter acts as a simple calculator: you can type an expression
at it and it will write the value.  Expression syntax is
straightforward: the operators `+', `-', `*' and `/' work just like in
most other languages (for example, Pascal or C); parentheses can be
used for grouping.  For example:

    >>> 2+2
    4
    >>> # This is a comment
    ... 2+2
    4
    >>> 2+2  # and a comment on the same line as code
    4
    >>> (50-5*6)/4
    5.0
    >>> 8/5 # Fractions aren't lost when dividing integers
    1.6

Note: You might not see exactly the same result; floating point results
can differ from one machine to another.  We will say more later about
controlling the appearance of floating point output.  See also *note
Floating Point Arithmetic; Issues and Limitations: 23. for a full
discussion of some of the subtleties of floating point numbers and their
representations.

  To do integer division and get an integer result, discarding any
fractional result, there is another operator, `//':

    >>> # Integer division returns the floor:
    ... 7//3
    2
    >>> 7//-3
    -3

The equal sign (`'='') is used to assign a value to a variable.
Afterwards, no result is displayed before the next interactive prompt:

    >>> width = 20
    >>> height = 5*9
    >>> width * height
    900

A value can be assigned to several variables simultaneously:

    >>> x = y = z = 0  # Zero x, y and z
    >>> x
    0
    >>> y
    0
    >>> z
    0

Variables must be "defined" (assigned a value) before they can be used,
or an error will occur:

    >>> # try to access an undefined variable
    ... n
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    NameError: name 'n' is not defined

There is full support for floating point; operators with mixed type
operands convert the integer operand to floating point:

    >>> 3 * 3.75 / 1.5
    7.5
    >>> 7.0 / 2
    3.5

Complex numbers are also supported; imaginary numbers are written with
a suffix of `j' or `J'.  Complex numbers with a nonzero real component
are written as `(real+imagj)', or can be created with the
`complex(real, imag)' function.

    >>> 1j * 1J
    (-1+0j)
    >>> 1j * complex(0, 1)
    (-1+0j)
    >>> 3+1j*3
    (3+3j)
    >>> (3+1j)*3
    (9+3j)
    >>> (1+2j)/(1+1j)
    (1.5+0.5j)

Complex numbers are always represented as two floating point numbers,
the real and imaginary part.  To extract these parts from a complex
number _z_, use `z.real' and `z.imag'.

    >>> a=1.5+0.5j
    >>> a.real
    1.5
    >>> a.imag
    0.5

The conversion functions to floating point and integer (`float()',
`int()') don't work for complex numbers -- there is not one correct way
to convert a complex number to a real number.  Use `abs(z)' to get its
magnitude (as a float) or `z.real' to get its real part:

    >>> a=3.0+4.0j
    >>> float(a)
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: can't convert complex to float; use abs(z)
    >>> a.real
    3.0
    >>> a.imag
    4.0
    >>> abs(a)  # sqrt(a.real**2 + a.imag**2)
    5.0

In interactive mode, the last printed expression is assigned to the
variable `_'.  This means that when you are using Python as a desk
calculator, it is somewhat easier to continue calculations, for example:

    >>> tax = 12.5 / 100
    >>> price = 100.50
    >>> price * tax
    12.5625
    >>> price + _
    113.0625
    >>> round(_, 2)
    113.06

This variable should be treated as read-only by the user.  Don't
explicitly assign a value to it -- you would create an independent
local variable with the same name masking the built-in variable with
its magic behavior.


File: python-tutorial-3.2.2.info,  Node: Strings,  Next: About Unicode,  Prev: Numbers,  Up: Using Python as a Calculator

3.1.2 Strings
-------------

Besides numbers, Python can also manipulate strings, which can be
expressed in several ways.  They can be enclosed in single quotes or
double quotes:

    >>> 'spam eggs'
    'spam eggs'
    >>> 'doesn\'t'
    "doesn't"
    >>> "doesn't"
    "doesn't"
    >>> '"Yes," he said.'
    '"Yes," he said.'
    >>> "\"Yes,\" he said."
    '"Yes," he said.'
    >>> '"Isn\'t," she said.'
    '"Isn\'t," she said.'

The interpreter prints the result of string operations in the same way
as they are typed for input: inside quotes, and with quotes and other
funny characters escaped by backslashes, to show the precise value.
The string is enclosed in double quotes if the string contains a single
quote and no double quotes, else it's enclosed in single quotes.  The
`print()' function produces a more readable output for such input
strings.

  String literals can span multiple lines in several ways.
Continuation lines can be used, with a backslash as the last character
on the line indicating that the next line is a logical continuation of
the line:

    hello = "This is a rather long string containing\n\
    several lines of text just as you would do in C.\n\
        Note that whitespace at the beginning of the line is\
     significant."

    print(hello)

Note that newlines still need to be embedded in the string using `\n' -
the newline following the trailing backslash is discarded.  This
example would print the following:

    This is a rather long string containing
    several lines of text just as you would do in C.
        Note that whitespace at the beginning of the line is significant.

Or, strings can be surrounded in a pair of matching triple-quotes:
`"""' or `''''.  End of lines do not need to be escaped when using
triple-quotes, but they will be included in the string.  So the
following uses one escape to avoid an unwanted initial blank line.

    print("""\
    Usage: thingy [OPTIONS]
         -h                        Display this usage message
         -H hostname               Hostname to connect to
    """)

produces the following output:

    Usage: thingy [OPTIONS]
         -h                        Display this usage message
         -H hostname               Hostname to connect to

If we make the string literal a "raw" string, `\n' sequences are not
converted to newlines, but the backslash at the end of the line, and
the newline character in the source, are both included in the string as
data.  Thus, the example:

    hello = r"This is a rather long string containing\n\
    several lines of text much as you would do in C."

    print(hello)

would print:

    This is a rather long string containing\n\
    several lines of text much as you would do in C.

Strings can be concatenated (glued together) with the `+' operator, and
repeated with `*':

    >>> word = 'Help' + 'A'
    >>> word
    'HelpA'
    >>> '<' + word*5 + '>'
    '<HelpAHelpAHelpAHelpAHelpA>'

Two string literals next to each other are automatically concatenated;
the first line above could also have been written `word = 'Help' 'A'';
this only works with two literals, not with arbitrary string
expressions:

    >>> 'str' 'ing'                   #  <-  This is ok
    'string'
    >>> 'str'.strip() + 'ing'   #  <-  This is ok
    'string'
    >>> 'str'.strip() 'ing'     #  <-  This is invalid
      File "<stdin>", line 1, in ?
        'str'.strip() 'ing'
                          ^
    SyntaxError: invalid syntax

Strings can be subscripted (indexed); like in C, the first character of
a string has subscript (index) 0.  There is no separate character type;
a character is simply a string of size one.  As in the Icon programming
language, substrings can be specified with the _slice notation_: two
indices separated by a colon.

    >>> word[4]
    'A'
    >>> word[0:2]
    'He'
    >>> word[2:4]
    'lp'

Slice indices have useful defaults; an omitted first index defaults to
zero, an omitted second index defaults to the size of the string being
sliced.

    >>> word[:2]    # The first two characters
    'He'
    >>> word[2:]    # Everything except the first two characters
    'lpA'

Unlike a C string, Python strings cannot be changed.  Assigning to an
indexed position in the string results in an error:

    >>> word[0] = 'x'
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: 'str' object does not support item assignment
    >>> word[:1] = 'Splat'
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: 'str' object does not support slice assignment

However, creating a new string with the combined content is easy and
efficient:

    >>> 'x' + word[1:]
    'xelpA'
    >>> 'Splat' + word[4]
    'SplatA'

Here's a useful invariant of slice operations: `s[:i] + s[i:]' equals
`s'.

    >>> word[:2] + word[2:]
    'HelpA'
    >>> word[:3] + word[3:]
    'HelpA'

Degenerate slice indices are handled gracefully: an index that is too
large is replaced by the string size, an upper bound smaller than the
lower bound returns an empty string.

    >>> word[1:100]
    'elpA'
    >>> word[10:]
    ''
    >>> word[2:1]
    ''

Indices may be negative numbers, to start counting from the right. For
example:

    >>> word[-1]     # The last character
    'A'
    >>> word[-2]     # The last-but-one character
    'p'
    >>> word[-2:]    # The last two characters
    'pA'
    >>> word[:-2]    # Everything except the last two characters
    'Hel'

But note that -0 is really the same as 0, so it does not count from the
right!

    >>> word[-0]     # (since -0 equals 0)
    'H'

Out-of-range negative slice indices are truncated, but don't try this
for single-element (non-slice) indices:

    >>> word[-100:]
    'HelpA'
    >>> word[-10]    # error
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    IndexError: string index out of range

One way to remember how slices work is to think of the indices as
pointing _between_ characters, with the left edge of the first
character numbered 0.  Then the right edge of the last character of a
string of _n_ characters has index _n_, for example:

     +---+---+---+---+---+
     | H | e | l | p | A |
     +---+---+---+---+---+
     0   1   2   3   4   5
    -5  -4  -3  -2  -1

The first row of numbers gives the position of the indices 0...5 in the
string; the second row gives the corresponding negative indices. The
slice from _i_ to _j_ consists of all characters between the edges
labeled _i_ and _j_, respectively.

  For non-negative indices, the length of a slice is the difference of
the indices, if both are within bounds.  For example, the length of
`word[1:3]' is 2.

  The built-in function `len()' returns the length of a string:

    >>> s = 'supercalifragilisticexpialidocious'
    >>> len(s)
    34


See also
........

_typesseq_
     Strings are examples of _sequence types_, and support the common
     operations supported by such types.

_string-methods_
     Strings support a large number of methods for basic
     transformations and searching.

_string-formatting_
     Information about string formatting with `str.format()' is
     described here.

_old-string-formatting_
     The old formatting operations invoked when strings and Unicode
     strings are the left operand of the `%' operator are described in
     more detail here.


File: python-tutorial-3.2.2.info,  Node: About Unicode,  Next: Lists,  Prev: Strings,  Up: Using Python as a Calculator

3.1.3 About Unicode
-------------------

Starting with Python 3.0 all strings support Unicode (see
<http://www.unicode.org/>).

  Unicode has the advantage of providing one ordinal for every
character in every script used in modern and ancient texts. Previously,
there were only 256 possible ordinals for script characters. Texts were
typically bound to a code page which mapped the ordinals to script
characters. This lead to very much confusion especially with respect to
internationalization (usually written as `i18n' -- `'i'' + 18
characters + `'n'') of software.  Unicode solves these problems by
defining one code page for all scripts.

  If you want to include special characters in a string, you can do so
by using the Python _Unicode-Escape_ encoding. The following example
shows how:

    >>> 'Hello\u0020World !'
    'Hello World !'

The escape sequence `\u0020' indicates to insert the Unicode character
with the ordinal value 0x0020 (the space character) at the given
position.

  Other characters are interpreted by using their respective ordinal
values directly as Unicode ordinals.  If you have literal strings in
the standard Latin-1 encoding that is used in many Western countries,
you will find it convenient that the lower 256 characters of Unicode
are the same as the 256 characters of Latin-1.

  Apart from these standard encodings, Python provides a whole set of
other ways of creating Unicode strings on the basis of a known encoding.

  To convert a string into a sequence of bytes using a specific
encoding, string objects provide an `encode()' method that takes one
argument, the name of the encoding.  Lowercase names for encodings are
preferred.

    >>> "Äpfel".encode('utf-8')
    b'\xc3\x84pfel'



File: python-tutorial-3.2.2.info,  Node: Lists,  Prev: About Unicode,  Up: Using Python as a Calculator

3.1.4 Lists
-----------

Python knows a number of _compound_ data types, used to group together
other values.  The most versatile is the _list_, which can be written
as a list of comma-separated values (items) between square brackets.
List items need not all have the same type.

    >>> a = ['spam', 'eggs', 100, 1234]
    >>> a
    ['spam', 'eggs', 100, 1234]

Like string indices, list indices start at 0, and lists can be sliced,
concatenated and so on:

    >>> a[0]
    'spam'
    >>> a[3]
    1234
    >>> a[-2]
    100
    >>> a[1:-1]
    ['eggs', 100]
    >>> a[:2] + ['bacon', 2*2]
    ['spam', 'eggs', 'bacon', 4]
    >>> 3*a[:3] + ['Boo!']
    ['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']

All slice operations return a new list containing the requested
elements.  This means that the following slice returns a shallow copy
of the list _a_:

    >>> a[:]
    ['spam', 'eggs', 100, 1234]

Unlike strings, which are _immutable_, it is possible to change
individual elements of a list:

    >>> a
    ['spam', 'eggs', 100, 1234]
    >>> a[2] = a[2] + 23
    >>> a
    ['spam', 'eggs', 123, 1234]

Assignment to slices is also possible, and this can even change the
size of the list or clear it entirely:

    >>> # Replace some items:
    ... a[0:2] = [1, 12]
    >>> a
    [1, 12, 123, 1234]
    >>> # Remove some:
    ... a[0:2] = []
    >>> a
    [123, 1234]
    >>> # Insert some:
    ... a[1:1] = ['bletch', 'xyzzy']
    >>> a
    [123, 'bletch', 'xyzzy', 1234]
    >>> # Insert (a copy of) itself at the beginning
    >>> a[:0] = a
    >>> a
    [123, 'bletch', 'xyzzy', 1234, 123, 'bletch', 'xyzzy', 1234]
    >>> # Clear the list: replace all items with an empty list
    >>> a[:] = []
    >>> a
    []

The built-in function `len()' also applies to lists:

    >>> a = ['a', 'b', 'c', 'd']
    >>> len(a)
    4

It is possible to nest lists (create lists containing other lists), for
example:

    >>> q = [2, 3]
    >>> p = [1, q, 4]
    >>> len(p)
    3
    >>> p[1]
    [2, 3]
    >>> p[1][0]
    2

You can add something to the end of the list:

    >>> p[1].append('xtra')
    >>> p
    [1, [2, 3, 'xtra'], 4]
    >>> q
    [2, 3, 'xtra']

Note that in the last example, `p[1]' and `q' really refer to the same
object!  We'll come back to _object semantics_ later.


File: python-tutorial-3.2.2.info,  Node: First Steps Towards Programming,  Prev: Using Python as a Calculator,  Up: An Informal Introduction to Python

3.2 First Steps Towards Programming
===================================

Of course, we can use Python for more complicated tasks than adding two
and two together.  For instance, we can write an initial sub-sequence
of the _Fibonacci_ series as follows:

    >>> # Fibonacci series:
    ... # the sum of two elements defines the next
    ... a, b = 0, 1
    >>> while b < 10:
    ...     print(b)
    ...     a, b = b, a+b
    ...
    1
    1
    2
    3
    5
    8

This example introduces several new features.

   * The first line contains a _multiple assignment_: the variables `a'
     and `b' simultaneously get the new values 0 and 1.  On the last
     line this is used again, demonstrating that the expressions on the
     right-hand side are all evaluated first before any of the
     assignments take place.  The right-hand side expressions are
     evaluated  from the left to the right.

   * The `while' loop executes as long as the condition (here: `b < 10')
     remains true.  In Python, like in C, any non-zero integer value is
     true; zero is false.  The condition may also be a string or list
     value, in fact any sequence; anything with a non-zero length is
     true, empty sequences are false.  The test used in the example is
     a simple comparison.  The standard comparison operators are
     written the same as in C: `<' (less than), `>' (greater than), `=='
     (equal to), `<=' (less than or equal to), `>=' (greater than or
     equal to) and `!=' (not equal to).

   * The _body_ of the loop is _indented_: indentation is Python's way
     of grouping statements.  Python does not (yet!) provide an
     intelligent input line editing facility, so you have to type a tab
     or space(s) for each indented line.  In practice you will prepare
     more complicated input for Python with a text editor; most text
     editors have an auto-indent facility.  When a compound statement is
     entered interactively, it must be followed by a blank line to
     indicate completion (since the parser cannot guess when you have
     typed the last line).  Note that each line within a basic block
     must be indented by the same amount.

   * The `print()' function writes the value of the expression(s) it is
     given.  It differs from just writing the expression you want to
     write (as we did earlier in the calculator examples) in the way it
     handles multiple expressions, floating point quantities, and
     strings.  Strings are printed without quotes, and a space is
     inserted between items, so you can format things nicely, like this:

         >>> i = 256*256
         >>> print('The value of i is', i)
         The value of i is 65536

     The keyword _end_ can be used to avoid the newline after the
     output, or end the output with a different string:

         >>> a, b = 0, 1
         >>> while b < 1000:
         ...     print(b, end=',')
         ...     a, b = b, a+b
         ...
         1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,




File: python-tutorial-3.2.2.info,  Node: More Control Flow Tools,  Next: Data Structures,  Prev: An Informal Introduction to Python,  Up: Top

4 More Control Flow Tools
*************************

Besides the `while' statement just introduced, Python knows the usual
control flow statements known from other languages, with some twists.

* Menu:

* if Statements::
* for Statements::
* The range() Function: The range Function.
* break and continue Statements, and else Clauses on Loops: break and continue Statements and else Clauses on Loops.
* pass Statements::
* Defining Functions::
* More on Defining Functions::
* Intermezzo; Coding Style: Intermezzo Coding Style.


File: python-tutorial-3.2.2.info,  Node: if Statements,  Next: for Statements,  Up: More Control Flow Tools

4.1 `if' Statements
===================

Perhaps the most well-known statement type is the `if' statement.  For
example:

    >>> x = int(input("Please enter an integer: "))
    Please enter an integer: 42
    >>> if x < 0:
    ...      x = 0
    ...      print('Negative changed to zero')
    ... elif x == 0:
    ...      print('Zero')
    ... elif x == 1:
    ...      print('Single')
    ... else:
    ...      print('More')
    ...
    More

There can be zero or more `elif' parts, and the `else' part is
optional.  The keyword '`elif'' is short for 'else if', and is useful
to avoid excessive indentation.  An  `if' ... `elif' ...  `elif' ...
sequence is a substitute for the `switch' or `case' statements found in
other languages.


File: python-tutorial-3.2.2.info,  Node: for Statements,  Next: The range Function,  Prev: if Statements,  Up: More Control Flow Tools

4.2 `for' Statements
====================

The `for' statement in Python differs a bit from what you may be used
to in C or Pascal.  Rather than always iterating over an arithmetic
progression of numbers (like in Pascal), or giving the user the ability
to define both the iteration step and halting condition (as C),
Python's `for' statement iterates over the items of any sequence (a
list or a string), in the order that they appear in the sequence.  For
example (no pun intended):

    >>> # Measure some strings:
    ... a = ['cat', 'window', 'defenestrate']
    >>> for x in a:
    ...     print(x, len(x))
    ...
    cat 3
    window 6
    defenestrate 12

It is not safe to modify the sequence being iterated over in the loop
(this can only happen for mutable sequence types, such as lists).  If
you need to modify the list you are iterating over (for example, to
duplicate selected items) you must iterate over a copy.  The slice
notation makes this particularly convenient:

    >>> for x in a[:]: # make a slice copy of the entire list
    ...    if len(x) > 6: a.insert(0, x)
    ...
    >>> a
    ['defenestrate', 'cat', 'window', 'defenestrate']



File: python-tutorial-3.2.2.info,  Node: The range Function,  Next: break and continue Statements and else Clauses on Loops,  Prev: for Statements,  Up: More Control Flow Tools

4.3 The `range()' Function
==========================

If you do need to iterate over a sequence of numbers, the built-in
function `range()' comes in handy.  It generates arithmetic
progressions:

    >>> for i in range(5):
    ...     print(i)
    ...
    0
    1
    2
    3
    4

The given end point is never part of the generated sequence;
`range(10)' generates 10 values, the legal indices for items of a
sequence of length 10.  It is possible to let the range start at
another number, or to specify a different increment (even negative;
sometimes this is called the 'step'):

    range(5, 10)
       5 through 9

    range(0, 10, 3)
       0, 3, 6, 9

    range(-10, -100, -30)
      -10, -40, -70

To iterate over the indices of a sequence, you can combine `range()' and
`len()' as follows:

    >>> a = ['Mary', 'had', 'a', 'little', 'lamb']
    >>> for i in range(len(a)):
    ...     print(i, a[i])
    ...
    0 Mary
    1 had
    2 a
    3 little
    4 lamb

In most such cases, however, it is convenient to use the `enumerate()'
function, see *note Looping Techniques: 35.

  A strange thing happens if you just print a range:

    >>> print(range(10))
    range(0, 10)

In many ways the object returned by `range()' behaves as if it is a
list, but in fact it isn't. It is an object which returns the
successive items of the desired sequence when you iterate over it, but
it doesn't really make the list, thus saving space.

  We say such an object is _iterable_, that is, suitable as a target for
functions and constructs that expect something from which they can
obtain successive items until the supply is exhausted. We have seen that
the `for' statement is such an _iterator_. The function `list()' is
another; it creates lists from iterables:

    >>> list(range(5))
    [0, 1, 2, 3, 4]

Later we will see more functions that return iterables and take
iterables as argument.


File: python-tutorial-3.2.2.info,  Node: break and continue Statements and else Clauses on Loops,  Next: pass Statements,  Prev: The range Function,  Up: More Control Flow Tools

4.4 `break' and `continue' Statements, and `else' Clauses on Loops
==================================================================

The `break' statement, like in C, breaks out of the smallest enclosing
`for' or `while' loop.

  The `continue' statement, also borrowed from C, continues with the
next iteration of the loop.

  Loop statements may have an `else' clause; it is executed when the
loop terminates through exhaustion of the list (with `for') or when the
condition becomes false (with `while'), but not when the loop is
terminated by a `break' statement.  This is exemplified by the
following loop, which searches for prime numbers:

    >>> for n in range(2, 10):
    ...     for x in range(2, n):
    ...         if n % x == 0:
    ...             print(n, 'equals', x, '*', n//x)
    ...             break
    ...     else:
    ...         # loop fell through without finding a factor
    ...         print(n, 'is a prime number')
    ...
    2 is a prime number
    3 is a prime number
    4 equals 2 * 2
    5 is a prime number
    6 equals 2 * 3
    7 is a prime number
    8 equals 2 * 4
    9 equals 3 * 3

(Yes, this is the correct code.  Look closely: the `else' clause
belongs to the `for' loop, *not* the `if' statement.)


File: python-tutorial-3.2.2.info,  Node: pass Statements,  Next: Defining Functions,  Prev: break and continue Statements and else Clauses on Loops,  Up: More Control Flow Tools

4.5 `pass' Statements
=====================

The `pass' statement does nothing. It can be used when a statement is
required syntactically but the program requires no action. For example:

    >>> while True:
    ...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
    ...

This is commonly used for creating minimal classes:

    >>> class MyEmptyClass:
    ...     pass
    ...

Another place `pass' can be used is as a place-holder for a function or
conditional body when you are working on new code, allowing you to keep
thinking at a more abstract level.  The `pass' is silently ignored:

    >>> def initlog(*args):
    ...     pass   # Remember to implement this!
    ...



File: python-tutorial-3.2.2.info,  Node: Defining Functions,  Next: More on Defining Functions,  Prev: pass Statements,  Up: More Control Flow Tools

4.6 Defining Functions
======================

We can create a function that writes the Fibonacci series to an
arbitrary boundary:

    >>> def fib(n):    # write Fibonacci series up to n
    ...     """Print a Fibonacci series up to n."""
    ...     a, b = 0, 1
    ...     while a < n:
    ...         print(a, end=' ')
    ...         a, b = b, a+b
    ...     print()
    ...
    >>> # Now call the function we just defined:
    ... fib(2000)
    0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597


  The keyword `def' introduces a function _definition_.  It must be
followed by the function name and the parenthesized list of formal
parameters.  The statements that form the body of the function start at
the next line, and must be indented.

  The first statement of the function body can optionally be a string
literal; this string literal is the function's documentation string, or
_docstring_.  (More about docstrings can be found in the section *note
Documentation Strings: 3c.)  There are tools which use docstrings to
automatically produce online or printed documentation, or to let the
user interactively browse through code; it's good practice to include
docstrings in code that you write, so make a habit of it.

  The _execution_ of a function introduces a new symbol table used for
the local variables of the function.  More precisely, all variable
assignments in a function store the value in the local symbol table;
whereas variable references first look in the local symbol table, then
in the local symbol tables of enclosing functions, then in the global
symbol table, and finally in the table of built-in names. Thus, global
variables cannot be directly assigned a value within a function (unless
named in a `global' statement), although they may be referenced.

  The actual parameters (arguments) to a function call are introduced
in the local symbol table of the called function when it is called;
thus, arguments are passed using _call by value_ (where the _value_ is
always an object _reference_, not the value of the object). (1) When a
function calls another function, a new local symbol table is created
for that call.

  A function definition introduces the function name in the current
symbol table.  The value of the function name has a type that is
recognized by the interpreter as a user-defined function.  This value
can be assigned to another name which can then also be used as a
function.  This serves as a general renaming mechanism:

    >>> fib
    <function fib at 10042ed0>
    >>> f = fib
    >>> f(100)
    0 1 1 2 3 5 8 13 21 34 55 89

Coming from other languages, you might object that `fib' is not a
function but a procedure since it doesn't return a value.  In fact,
even functions without a `return' statement do return a value, albeit a
rather boring one.  This value is called `None' (it's a built-in name).
Writing the value `None' is normally suppressed by the interpreter if
it would be the only value written.  You can see it if you really want
to using `print()':

    >>> fib(0)
    >>> print(fib(0))
    None

It is simple to write a function that returns a list of the numbers of
the Fibonacci series, instead of printing it:

    >>> def fib2(n): # return Fibonacci series up to n
    ...     """Return a list containing the Fibonacci series up to n."""
    ...     result = []
    ...     a, b = 0, 1
    ...     while a < n:
    ...         result.append(a)    # see below
    ...         a, b = b, a+b
    ...     return result
    ...
    >>> f100 = fib2(100)    # call it
    >>> f100                # write the result
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

This example, as usual, demonstrates some new Python features:

   * The `return' statement returns with a value from a function.
     `return' without an expression argument returns `None'. Falling off
     the end of a function also returns `None'.

   * The statement `result.append(a)' calls a _method_ of the list
     object `result'.  A method is a function that 'belongs' to an
     object and is named `obj.methodname', where `obj' is some object
     (this may be an expression), and `methodname' is the name of a
     method that is defined by the object's type.  Different types
     define different methods.  Methods of different types may have the
     same name without causing ambiguity.  (It is possible to define
     your own object types and methods, using _classes_, see *note
     Classes: 3d.)  The method `append()' shown in the example is
     defined for list objects; it adds a new element at the end of the
     list.  In this example it is equivalent to `result = result +
     [a]', but more efficient.

  ---------- Footnotes ----------

  (1) Actually, _call by object reference_ would be a better
description, since if a mutable object is passed, the caller will see
any changes the callee makes to it (items inserted into a list).


File: python-tutorial-3.2.2.info,  Node: More on Defining Functions,  Next: Intermezzo Coding Style,  Prev: Defining Functions,  Up: More Control Flow Tools

4.7 More on Defining Functions
==============================

It is also possible to define functions with a variable number of
arguments.  There are three forms, which can be combined.

* Menu:

* Default Argument Values::
* Keyword Arguments::
* Arbitrary Argument Lists::
* Unpacking Argument Lists::
* Lambda Forms::
* Documentation Strings::


File: python-tutorial-3.2.2.info,  Node: Default Argument Values,  Next: Keyword Arguments,  Up: More on Defining Functions

4.7.1 Default Argument Values
-----------------------------

The most useful form is to specify a default value for one or more
arguments.  This creates a function that can be called with fewer
arguments than it is defined to allow.  For example:

    def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
        while True:
            ok = input(prompt)
            if ok in ('y', 'ye', 'yes'):
                return True
            if ok in ('n', 'no', 'nop', 'nope'):
                return False
            retries = retries - 1
            if retries < 0:
                raise IOError('refusenik user')
            print(complaint)

This function can be called in several ways:

   * giving only the mandatory argument: `ask_ok('Do you really want to
     quit?')'

   * giving one of the optional arguments: `ask_ok('OK to overwrite the
     file?', 2)'

   * or even giving all arguments: `ask_ok('OK to overwrite the file?',
     2, 'Come on, only yes or no!')'

  This example also introduces the `in' keyword. This tests whether or
not a sequence contains a certain value.

  The default values are evaluated at the point of function definition
in the _defining_ scope, so that

    i = 5

    def f(arg=i):
        print(arg)

    i = 6
    f()

will print `5'.

  *Important warning:*  The default value is evaluated only once. This
makes a difference when the default is a mutable object such as a list,
dictionary, or instances of most classes.  For example, the following
function accumulates the arguments passed to it on subsequent calls:

    def f(a, L=[]):
        L.append(a)
        return L

    print(f(1))
    print(f(2))
    print(f(3))

This will print

    [1]
    [1, 2]
    [1, 2, 3]

If you don't want the default to be shared between subsequent calls,
you can write the function like this instead:

    def f(a, L=None):
        if L is None:
            L = []
        L.append(a)
        return L



File: python-tutorial-3.2.2.info,  Node: Keyword Arguments,  Next: Arbitrary Argument Lists,  Prev: Default Argument Values,  Up: More on Defining Functions

4.7.2 Keyword Arguments
-----------------------

Functions can also be called using keyword arguments of the form
`keyword = value'.  For instance, the following function:

    def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
        print("-- This parrot wouldn't", action, end=' ')
        print("if you put", voltage, "volts through it.")
        print("-- Lovely plumage, the", type)
        print("-- It's", state, "!")

could be called in any of the following ways:

    parrot(1000)
    parrot(action = 'VOOOOOM', voltage = 1000000)
    parrot('a thousand', state = 'pushing up the daisies')
    parrot('a million', 'bereft of life', 'jump')

but the following calls would all be invalid:

    parrot()                     # required argument missing
    parrot(voltage=5.0, 'dead')  # non-keyword argument following keyword
    parrot(110, voltage=220)     # duplicate value for argument
    parrot(actor='John Cleese')  # unknown keyword

In general, an argument list must have any positional arguments
followed by any keyword arguments, where the keywords must be chosen
from the formal parameter names.  It's not important whether a formal
parameter has a default value or not.  No argument may receive a value
more than once -- formal parameter names corresponding to positional
arguments cannot be used as keywords in the same calls. Here's an
example that fails due to this restriction:

    >>> def function(a):
    ...     pass
    ...
    >>> function(0, a=0)
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: function() got multiple values for keyword argument 'a'

When a final formal parameter of the form `**name' is present, it
receives a dictionary (see _typesmapping_) containing all keyword
arguments except for those corresponding to a formal parameter.  This
may be combined with a formal parameter of the form `*name' (described
in the next subsection) which receives a tuple containing the
positional arguments beyond the formal parameter list.  (`*name' must
occur before `**name'.) For example, if we define a function like this:

    def cheeseshop(kind, *arguments, **keywords):
        print("-- Do you have any", kind, "?")
        print("-- I'm sorry, we're all out of", kind)
        for arg in arguments:
            print(arg)
        print("-" * 40)
        keys = sorted(keywords.keys())
        for kw in keys:
            print(kw, ":", keywords[kw])

It could be called like this:

    cheeseshop("Limburger", "It's very runny, sir.",
               "It's really very, VERY runny, sir.",
               shopkeeper="Michael Palin",
               client="John Cleese",
               sketch="Cheese Shop Sketch")

and of course it would print:

    -- Do you have any Limburger ?
    -- I'm sorry, we're all out of Limburger
    It's very runny, sir.
    It's really very, VERY runny, sir.
    ----------------------------------------
    client : John Cleese
    shopkeeper : Michael Palin
    sketch : Cheese Shop Sketch

Note that the list of keyword argument names is created by sorting the
result of the keywords dictionary's `keys()' method before printing its
contents; if this is not done, the order in which the arguments are
printed is undefined.


File: python-tutorial-3.2.2.info,  Node: Arbitrary Argument Lists,  Next: Unpacking Argument Lists,  Prev: Keyword Arguments,  Up: More on Defining Functions

4.7.3 Arbitrary Argument Lists
------------------------------

Finally, the least frequently used option is to specify that a function
can be called with an arbitrary number of arguments.  These arguments
will be wrapped up in a tuple (see *note Tuples and Sequences: 46.).
Before the variable number of arguments, zero or more normal arguments
may occur.

    def write_multiple_items(file, separator, *args):
        file.write(separator.join(args))

Normally, these `variadic' arguments will be last in the list of formal
parameters, because they scoop up all remaining input arguments that are
passed to the function. Any formal parameters which occur after the
`*args' parameter are 'keyword-only' arguments, meaning that they can
only be used as keywords rather than positional arguments.

    >>> def concat(*args, sep="/"):
    ...    return sep.join(args)
    ...
    >>> concat("earth", "mars", "venus")
    'earth/mars/venus'
    >>> concat("earth", "mars", "venus", sep=".")
    'earth.mars.venus'



File: python-tutorial-3.2.2.info,  Node: Unpacking Argument Lists,  Next: Lambda Forms,  Prev: Arbitrary Argument Lists,  Up: More on Defining Functions

4.7.4 Unpacking Argument Lists
------------------------------

The reverse situation occurs when the arguments are already in a list
or tuple but need to be unpacked for a function call requiring separate
positional arguments.  For instance, the built-in `range()' function
expects separate _start_ and _stop_ arguments.  If they are not
available separately, write the function call with the  `*'-operator to
unpack the arguments out of a list or tuple:

    >>> list(range(3, 6))            # normal call with separate arguments
    [3, 4, 5]
    >>> args = [3, 6]
    >>> list(range(*args))            # call with arguments unpacked from a list
    [3, 4, 5]


  In the same fashion, dictionaries can deliver keyword arguments with
the `**'-operator:

    >>> def parrot(voltage, state='a stiff', action='voom'):
    ...     print("-- This parrot wouldn't", action, end=' ')
    ...     print("if you put", voltage, "volts through it.", end=' ')
    ...     print("E's", state, "!")
    ...
    >>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
    >>> parrot(**d)
    -- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !



File: python-tutorial-3.2.2.info,  Node: Lambda Forms,  Next: Documentation Strings,  Prev: Unpacking Argument Lists,  Up: More on Defining Functions

4.7.5 Lambda Forms
------------------

By popular demand, a few features commonly found in functional
programming languages like Lisp have been added to Python.  With the
`lambda' keyword, small anonymous functions can be created. Here's a
function that returns the sum of its two arguments: `lambda a, b: a+b'.
Lambda forms can be used wherever function objects are required.  They
are syntactically restricted to a single expression.  Semantically,
they are just syntactic sugar for a normal function definition.  Like
nested function definitions, lambda forms can reference variables from
the containing scope:

    >>> def make_incrementor(n):
    ...     return lambda x: x + n
    ...
    >>> f = make_incrementor(42)
    >>> f(0)
    42
    >>> f(1)
    43



File: python-tutorial-3.2.2.info,  Node: Documentation Strings,  Prev: Lambda Forms,  Up: More on Defining Functions

4.7.6 Documentation Strings
---------------------------

Here are some conventions about the content and formatting of
documentation strings.

  The first line should always be a short, concise summary of the
object's purpose.  For brevity, it should not explicitly state the
object's name or type, since these are available by other means (except
if the name happens to be a verb describing a function's operation).
This line should begin with a capital letter and end with a period.

  If there are more lines in the documentation string, the second line
should be blank, visually separating the summary from the rest of the
description.  The following lines should be one or more paragraphs
describing the object's calling conventions, its side effects, etc.

  The Python parser does not strip indentation from multi-line string
literals in Python, so tools that process documentation have to strip
indentation if desired.  This is done using the following convention.
The first non-blank line _after_ the first line of the string
determines the amount of indentation for the entire documentation
string.  (We can't use the first line since it is generally adjacent to
the string's opening quotes so its indentation is not apparent in the
string literal.)  Whitespace "equivalent" to this indentation is then
stripped from the start of all lines of the string.  Lines that are
indented less should not occur, but if they occur all their leading
whitespace should be stripped.  Equivalence of whitespace should be
tested after expansion of tabs (to 8 spaces, normally).

  Here is an example of a multi-line docstring:

    >>> def my_function():
    ...     """Do nothing, but document it.
    ...
    ...     No, really, it doesn't do anything.
    ...     """
    ...     pass
    ...
    >>> print(my_function.__doc__)
    Do nothing, but document it.

        No, really, it doesn't do anything.



File: python-tutorial-3.2.2.info,  Node: Intermezzo Coding Style,  Prev: More on Defining Functions,  Up: More Control Flow Tools

4.8 Intermezzo: Coding Style
============================

Now that you are about to write longer, more complex pieces of Python,
it is a good time to talk about _coding style_.  Most languages can be
written (or more concise, _formatted_) in different styles; some are
more readable than others.  Making it easy for others to read your code
is always a good idea, and adopting a nice coding style helps
tremendously for that.

  For Python, PEP 8(1) has emerged as the style guide that most
projects adhere to; it promotes a very readable and eye-pleasing coding
style.  Every Python developer should read it at some point; here are
the most important points extracted for you:

   * Use 4-space indentation, and no tabs.

     4 spaces are a good compromise between small indentation (allows
     greater nesting depth) and large indentation (easier to read).
     Tabs introduce confusion, and are best left out.

   * Wrap lines so that they don't exceed 79 characters.

     This helps users with small displays and makes it possible to have
     several code files side-by-side on larger displays.

   * Use blank lines to separate functions and classes, and larger
     blocks of code inside functions.

   * When possible, put comments on a line of their own.

   * Use docstrings.

   * Use spaces around operators and after commas, but not directly
     inside bracketing constructs: `a = f(1, 2) + g(3, 4)'.

   * Name your classes and functions consistently; the convention is to
     use `CamelCase' for classes and `lower_case_with_underscores' for
     functions and methods.  Always use `self' as the name for the
     first method argument (see *note A First Look at Classes: 4e. for
     more on classes and methods).

   * Don't use fancy encodings if your code is meant to be used in
     international environments.  Python's default, UTF-8, or even
     plain ASCII work best in any case.

   * Likewise, don't use non-ASCII characters in identifiers if there
     is only the slightest chance people speaking a different language
     will read or maintain the code.

  ---------- Footnotes ----------

  (1) http://www.python.org/dev/peps/pep-0008


File: python-tutorial-3.2.2.info,  Node: Data Structures,  Next: Modules,  Prev: More Control Flow Tools,  Up: Top

5 Data Structures
*****************

This chapter describes some things you've learned about already in more
detail, and adds some new things as well.

* Menu:

* More on Lists::
* The del statement::
* Tuples and Sequences::
* Sets::
* Dictionaries::
* Looping Techniques::
* More on Conditions::
* Comparing Sequences and Other Types::

More on Lists

* Using Lists as Stacks::
* Using Lists as Queues::
* List Comprehensions::
* Nested List Comprehensions::


File: python-tutorial-3.2.2.info,  Node: More on Lists,  Next: The del statement,  Up: Data Structures

5.1 More on Lists
=================

The list data type has some more methods.  Here are all of the methods
of list objects:

 -- Method: list.append (x)
     Add an item to the end of the list; equivalent to `a[len(a):] =
     [x]'.

 -- Method: list.extend (L)
     Extend the list by appending all the items in the given list;
     equivalent to `a[len(a):] = L'.

 -- Method: list.insert (i, x)
     Insert an item at a given position.  The first argument is the
     index of the element before which to insert, so `a.insert(0, x)'
     inserts at the front of the list, and `a.insert(len(a), x)' is
     equivalent to `a.append(x)'.

 -- Method: list.remove (x)
     Remove the first item from the list whose value is _x_. It is an
     error if there is no such item.

 -- Method: list.pop ([i])
     Remove the item at the given position in the list, and return it.
     If no index is specified, `a.pop()' removes and returns the last
     item in the list.  (The square brackets around the _i_ in the
     method signature denote that the parameter is optional, not that
     you should type square brackets at that position.  You will see
     this notation frequently in the Python Library Reference.)

 -- Method: list.index (x)
     Return the index in the list of the first item whose value is _x_.
     It is an error if there is no such item.

 -- Method: list.count (x)
     Return the number of times _x_ appears in the list.

 -- Method: list.sort ()
     Sort the items of the list, in place.

 -- Method: list.reverse ()
     Reverse the elements of the list, in place.

  An example that uses most of the list methods:

    >>> a = [66.25, 333, 333, 1, 1234.5]
    >>> print(a.count(333), a.count(66.25), a.count('x'))
    2 1 0
    >>> a.insert(2, -1)
    >>> a.append(333)
    >>> a
    [66.25, 333, -1, 333, 1, 1234.5, 333]
    >>> a.index(333)
    1
    >>> a.remove(333)
    >>> a
    [66.25, -1, 333, 1, 1234.5, 333]
    >>> a.reverse()
    >>> a
    [333, 1234.5, 1, 333, -1, 66.25]
    >>> a.sort()
    >>> a
    [-1, 1, 66.25, 333, 333, 1234.5]


* Menu:

* Using Lists as Stacks::
* Using Lists as Queues::
* List Comprehensions::
* Nested List Comprehensions::


File: python-tutorial-3.2.2.info,  Node: Using Lists as Stacks,  Next: Using Lists as Queues,  Up: More on Lists

5.1.1 Using Lists as Stacks
---------------------------

The list methods make it very easy to use a list as a stack, where the
last element added is the first element retrieved ("last-in,
first-out").  To add an item to the top of the stack, use `append()'.
To retrieve an item from the top of the stack, use `pop()' without an
explicit index.  For example:

    >>> stack = [3, 4, 5]
    >>> stack.append(6)
    >>> stack.append(7)
    >>> stack
    [3, 4, 5, 6, 7]
    >>> stack.pop()
    7
    >>> stack
    [3, 4, 5, 6]
    >>> stack.pop()
    6
    >>> stack.pop()
    5
    >>> stack
    [3, 4]



File: python-tutorial-3.2.2.info,  Node: Using Lists as Queues,  Next: List Comprehensions,  Prev: Using Lists as Stacks,  Up: More on Lists

5.1.2 Using Lists as Queues
---------------------------

It is also possible to use a list as a queue, where the first element
added is the first element retrieved ("first-in, first-out"); however,
lists are not efficient for this purpose.  While appends and pops from
the end of list are fast, doing inserts or pops from the beginning of a
list is slow (because all of the other elements have to be shifted by
one).

  To implement a queue, use `collections.deque' which was designed to
have fast appends and pops from both ends.  For example:

    >>> from collections import deque
    >>> queue = deque(["Eric", "John", "Michael"])
    >>> queue.append("Terry")           # Terry arrives
    >>> queue.append("Graham")          # Graham arrives
    >>> queue.popleft()                 # The first to arrive now leaves
    'Eric'
    >>> queue.popleft()                 # The second to arrive now leaves
    'John'
    >>> queue                           # Remaining queue in order of arrival
    deque(['Michael', 'Terry', 'Graham'])



File: python-tutorial-3.2.2.info,  Node: List Comprehensions,  Next: Nested List Comprehensions,  Prev: Using Lists as Queues,  Up: More on Lists

5.1.3 List Comprehensions
-------------------------

List comprehensions provide a concise way to create lists from
sequences.  Common applications are to make lists where each element is
the result of some operations applied to each member of the sequence,
or to create a subsequence of those elements that satisfy a certain
condition.

  A list comprehension consists of brackets containing an expression
followed by a `for' clause, then zero or more `for' or `if' clauses.
The result will be a list resulting from evaluating the expression in
the context of the `for' and `if' clauses which follow it.  If the
expression would evaluate to a tuple, it must be parenthesized.

  Here we take a list of numbers and return a list of three times each
number:

    >>> vec = [2, 4, 6]
    >>> [3*x for x in vec]
    [6, 12, 18]

Now we get a little fancier:

    >>> [[x, x**2] for x in vec]
    [[2, 4], [4, 16], [6, 36]]

Here we apply a method call to each item in a sequence:

    >>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
    >>> [weapon.strip() for weapon in freshfruit]
    ['banana', 'loganberry', 'passion fruit']

Using the `if' clause we can filter the stream:

    >>> [3*x for x in vec if x > 3]
    [12, 18]
    >>> [3*x for x in vec if x < 2]
    []

Tuples can often be created without their parentheses, but not here:

    >>> [x, x**2 for x in vec]  # error - parens required for tuples
      File "<stdin>", line 1, in ?
        [x, x**2 for x in vec]
                   ^
    SyntaxError: invalid syntax
    >>> [(x, x**2) for x in vec]
    [(2, 4), (4, 16), (6, 36)]

Here are some nested for loops and other fancy behavior:

    >>> vec1 = [2, 4, 6]
    >>> vec2 = [4, 3, -9]
    >>> [x*y for x in vec1 for y in vec2]
    [8, 6, -18, 16, 12, -36, 24, 18, -54]
    >>> [x+y for x in vec1 for y in vec2]
    [6, 5, -7, 8, 7, -5, 10, 9, -3]
    >>> [vec1[i]*vec2[i] for i in range(len(vec1))]
    [8, 12, -54]

List comprehensions can be applied to complex expressions and nested
functions:

    >>> [str(round(355/113, i)) for i in range(1, 6)]
    ['3.1', '3.14', '3.142', '3.1416', '3.14159']



File: python-tutorial-3.2.2.info,  Node: Nested List Comprehensions,  Prev: List Comprehensions,  Up: More on Lists

5.1.4 Nested List Comprehensions
--------------------------------

If you've got the stomach for it, list comprehensions can be nested.
They are a powerful tool but - like all powerful tools - they need to
be used carefully, if at all.

  Consider the following example of a 3x3 matrix held as a list
containing three lists, one list per row:

    >>> mat = [
    ...        [1, 2, 3],
    ...        [4, 5, 6],
    ...        [7, 8, 9],
    ...       ]

Now, if you wanted to swap rows and columns, you could use a list
comprehension:

    >>> print([[row[i] for row in mat] for i in [0, 1, 2]])
    [[1, 4, 7], [2, 5, 8], [3, 6, 9]]

Special care has to be taken for the _nested_ list comprehension:

     To avoid apprehension when nesting list comprehensions, read from
     right to left.

  A more verbose version of this snippet shows the flow explicitly:

    for i in [0, 1, 2]:
        for row in mat:
            print(row[i], end="")
        print()

In real world, you should prefer built-in functions to complex flow
statements.  The `zip()' function would do a great job for this use
case:

    >>> list(zip(*mat))
    [(1, 4, 7), (2, 5, 8), (3, 6, 9)]

See *note Unpacking Argument Lists: 47. for details on the asterisk in
this line.


File: python-tutorial-3.2.2.info,  Node: The del statement,  Next: Tuples and Sequences,  Prev: More on Lists,  Up: Data Structures

5.2 The `del' statement
=======================

There is a way to remove an item from a list given its index instead of
its value: the `del' statement.  This differs from the `pop()' method
which returns a value.  The `del' statement can also be used to remove
slices from a list or clear the entire list (which we did earlier by
assignment of an empty list to the slice).  For example:

    >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
    >>> del a[0]
    >>> a
    [1, 66.25, 333, 333, 1234.5]
    >>> del a[2:4]
    >>> a
    [1, 66.25, 1234.5]
    >>> del a[:]
    >>> a
    []

`del' can also be used to delete entire variables:

    >>> del a

Referencing the name `a' hereafter is an error (at least until another
value is assigned to it).  We'll find other uses for `del' later.


File: python-tutorial-3.2.2.info,  Node: Tuples and Sequences,  Next: Sets,  Prev: The del statement,  Up: Data Structures

5.3 Tuples and Sequences
========================

We saw that lists and strings have many common properties, such as
indexing and slicing operations.  They are two examples of _sequence_
data types (see _typesseq_).  Since Python is an evolving language,
other sequence data types may be added.  There is also another standard
sequence data type: the _tuple_.

  A tuple consists of a number of values separated by commas, for
instance:

    >>> t = 12345, 54321, 'hello!'
    >>> t[0]
    12345
    >>> t
    (12345, 54321, 'hello!')
    >>> # Tuples may be nested:
    ... u = t, (1, 2, 3, 4, 5)
    >>> u
    ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))

As you see, on output tuples are always enclosed in parentheses, so
that nested tuples are interpreted correctly; they may be input with or
without surrounding parentheses, although often parentheses are
necessary anyway (if the tuple is part of a larger expression).

  Tuples have many uses.  For example: (x, y) coordinate pairs,
employee records from a database, etc.  Tuples, like strings, are
immutable: it is not possible to assign to the individual items of a
tuple (you can simulate much of the same effect with slicing and
concatenation, though).  It is also possible to create tuples which
contain mutable objects, such as lists.

  A special problem is the construction of tuples containing 0 or 1
items: the syntax has some extra quirks to accommodate these.  Empty
tuples are constructed by an empty pair of parentheses; a tuple with
one item is constructed by following a value with a comma (it is not
sufficient to enclose a single value in parentheses). Ugly, but
effective.  For example:

    >>> empty = ()
    >>> singleton = 'hello',    # <-- note trailing comma
    >>> len(empty)
    0
    >>> len(singleton)
    1
    >>> singleton
    ('hello',)

The statement `t = 12345, 54321, 'hello!'' is an example of _tuple
packing_: the values `12345', `54321' and `'hello!'' are packed
together in a tuple.  The reverse operation is also possible:

    >>> x, y, z = t

This is called, appropriately enough, _sequence unpacking_ and works
for any sequence on the right-hand side.  Sequence unpacking requires
that there are as many variables on the left side of the equals sign as
there are elements in the sequence.  Note that multiple assignment is
really just a combination of tuple packing and sequence unpacking.


File: python-tutorial-3.2.2.info,  Node: Sets,  Next: Dictionaries,  Prev: Tuples and Sequences,  Up: Data Structures

5.4 Sets
========

Python also includes a data type for _sets_.  A set is an unordered
collection with no duplicate elements.  Basic uses include membership
testing and eliminating duplicate entries.  Set objects also support
mathematical operations like union, intersection, difference, and
symmetric difference.

  Curly braces or the `set()' function can be used to create sets.
Note: To create an empty set you have to use `set()', not `{}'; the
latter creates an empty dictionary, a data structure that we discuss in
the next section.

  Here is a brief demonstration:

    >>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
    >>> print(basket)                      # show that duplicates have been removed
    {'orange', 'banana', 'pear', 'apple'}
    >>> 'orange' in basket                 # fast membership testing
    True
    >>> 'crabgrass' in basket
    False

    >>> # Demonstrate set operations on unique letters from two words
    ...
    >>> a = set('abracadabra')
    >>> b = set('alacazam')
    >>> a                                  # unique letters in a
    {'a', 'r', 'b', 'c', 'd'}
    >>> a - b                              # letters in a but not in b
    {'r', 'd', 'b'}
    >>> a | b                              # letters in either a or b
    {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
    >>> a & b                              # letters in both a and b
    {'a', 'c'}
    >>> a ^ b                              # letters in a or b but not both
    {'r', 'd', 'b', 'm', 'z', 'l'}

Like *note for lists: 58, there is a set comprehension syntax:

    >>> a = {x for x in 'abracadabra' if x not in 'abc'}
    >>> a
    {'r', 'd'}



File: python-tutorial-3.2.2.info,  Node: Dictionaries,  Next: Looping Techniques,  Prev: Sets,  Up: Data Structures

5.5 Dictionaries
================

Another useful data type built into Python is the _dictionary_ (see
_typesmapping_). Dictionaries are sometimes found in other languages as
"associative memories" or "associative arrays".  Unlike sequences,
which are indexed by a range of numbers, dictionaries are indexed by
_keys_, which can be any immutable type; strings and numbers can always
be keys.  Tuples can be used as keys if they contain only strings,
numbers, or tuples; if a tuple contains any mutable object either
directly or indirectly, it cannot be used as a key.  You can't use
lists as keys, since lists can be modified in place using index
assignments, slice assignments, or methods like `append()' and
`extend()'.

  It is best to think of a dictionary as an unordered set of _key:
value_ pairs, with the requirement that the keys are unique (within one
dictionary). A pair of braces creates an empty dictionary: `{}'.
Placing a comma-separated list of key:value pairs within the braces
adds initial key:value pairs to the dictionary; this is also the way
dictionaries are written on output.

  The main operations on a dictionary are storing a value with some key
and extracting the value given the key.  It is also possible to delete
a key:value pair with `del'. If you store using a key that is already
in use, the old value associated with that key is forgotten.  It is an
error to extract a value using a non-existent key.

  Performing `list(d.keys())' on a dictionary returns a list of all the
keys used in the dictionary, in arbitrary order (if you want it sorted,
just use `sorted(d.keys())' instead). (1)  To check whether a single
key is in the dictionary, use the `in' keyword.

  Here is a small example using a dictionary:

    >>> tel = {'jack': 4098, 'sape': 4139}
    >>> tel['guido'] = 4127
    >>> tel
    {'sape': 4139, 'guido': 4127, 'jack': 4098}
    >>> tel['jack']
    4098
    >>> del tel['sape']
    >>> tel['irv'] = 4127
    >>> tel
    {'guido': 4127, 'irv': 4127, 'jack': 4098}
    >>> list(tel.keys())
    ['irv', 'guido', 'jack']
    >>> sorted(tel.keys())
    ['guido', 'irv', 'jack']
    >>> 'guido' in tel
    True
    >>> 'jack' not in tel
    False

The `dict()' constructor builds dictionaries directly from sequences of
key-value pairs:

    >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
    {'sape': 4139, 'jack': 4098, 'guido': 4127}

In addition, dict comprehensions can be used to create dictionaries from
arbitrary key and value expressions:

    >>> {x: x**2 for x in (2, 4, 6)}
    {2: 4, 4: 16, 6: 36}

When the keys are simple strings, it is sometimes easier to specify
pairs using keyword arguments:

    >>> dict(sape=4139, guido=4127, jack=4098)
    {'sape': 4139, 'jack': 4098, 'guido': 4127}


  ---------- Footnotes ----------

  (1) Calling `d.keys()' will return a _dictionary view_ object.  It
supports operations like membership test and iteration, but its contents
are not independent of the original dictionary - it is only a _view_.


File: python-tutorial-3.2.2.info,  Node: Looping Techniques,  Next: More on Conditions,  Prev: Dictionaries,  Up: Data Structures

5.6 Looping Techniques
======================

When looping through dictionaries, the key and corresponding value can
be retrieved at the same time using the `items()' method.

    >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
    >>> for k, v in knights.items():
    ...     print(k, v)
    ...
    gallahad the pure
    robin the brave

When looping through a sequence, the position index and corresponding
value can be retrieved at the same time using the `enumerate()'
function.

    >>> for i, v in enumerate(['tic', 'tac', 'toe']):
    ...     print(i, v)
    ...
    0 tic
    1 tac
    2 toe

To loop over two or more sequences at the same time, the entries can be
paired with the `zip()' function.

    >>> questions = ['name', 'quest', 'favorite color']
    >>> answers = ['lancelot', 'the holy grail', 'blue']
    >>> for q, a in zip(questions, answers):
    ...     print('What is your {0}?  It is {1}.'.format(q, a))
    ...
    What is your name?  It is lancelot.
    What is your quest?  It is the holy grail.
    What is your favorite color?  It is blue.

To loop over a sequence in reverse, first specify the sequence in a
forward direction and then call the `reversed()' function.

    >>> for i in reversed(range(1, 10, 2)):
    ...     print(i)
    ...
    9
    7
    5
    3
    1

To loop over a sequence in sorted order, use the `sorted()' function
which returns a new sorted list while leaving the source unaltered.

    >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
    >>> for f in sorted(set(basket)):
    ...     print(f)
    ...
    apple
    banana
    orange
    pear



File: python-tutorial-3.2.2.info,  Node: More on Conditions,  Next: Comparing Sequences and Other Types,  Prev: Looping Techniques,  Up: Data Structures

5.7 More on Conditions
======================

The conditions used in `while' and `if' statements can contain any
operators, not just comparisons.

  The comparison operators `in' and `not in' check whether a value
occurs (does not occur) in a sequence.  The operators `is' and `is not'
compare whether two objects are really the same object; this only
matters for mutable objects like lists.  All comparison operators have
the same priority, which is lower than that of all numerical operators.

  Comparisons can be chained.  For example, `a < b == c' tests whether
`a' is less than `b' and moreover `b' equals `c'.

  Comparisons may be combined using the Boolean operators `and' and
`or', and the outcome of a comparison (or of any other Boolean
expression) may be negated with `not'.  These have lower priorities
than comparison operators; between them, `not' has the highest priority
and `or' the lowest, so that `A and not B or C' is equivalent to `(A
and (not B)) or C'. As always, parentheses can be used to express the
desired composition.

  The Boolean operators `and' and `or' are so-called _short-circuit_
operators: their arguments are evaluated from left to right, and
evaluation stops as soon as the outcome is determined.  For example, if
`A' and `C' are true but `B' is false, `A and B and C' does not
evaluate the expression `C'.  When used as a general value and not as a
Boolean, the return value of a short-circuit operator is the last
evaluated argument.

  It is possible to assign the result of a comparison or other Boolean
expression to a variable.  For example,

    >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
    >>> non_null = string1 or string2 or string3
    >>> non_null
    'Trondheim'

Note that in Python, unlike C, assignment cannot occur inside
expressions. C programmers may grumble about this, but it avoids a
common class of problems encountered in C programs: typing `=' in an
expression when `==' was intended.


File: python-tutorial-3.2.2.info,  Node: Comparing Sequences and Other Types,  Prev: More on Conditions,  Up: Data Structures

5.8 Comparing Sequences and Other Types
=======================================

Sequence objects may be compared to other objects with the same
sequence type.  The comparison uses _lexicographical_ ordering: first
the first two items are compared, and if they differ this determines
the outcome of the comparison; if they are equal, the next two items
are compared, and so on, until either sequence is exhausted. If two
items to be compared are themselves sequences of the same type, the
lexicographical comparison is carried out recursively.  If all items of
two sequences compare equal, the sequences are considered equal.  If
one sequence is an initial sub-sequence of the other, the shorter
sequence is the smaller (lesser) one.  Lexicographical ordering for
strings uses the Unicode codepoint number to order individual
characters.  Some examples of comparisons between sequences of the same
type:

    (1, 2, 3)              < (1, 2, 4)
    [1, 2, 3]              < [1, 2, 4]
    'ABC' < 'C' < 'Pascal' < 'Python'
    (1, 2, 3, 4)           < (1, 2, 4)
    (1, 2)                 < (1, 2, -1)
    (1, 2, 3)             == (1.0, 2.0, 3.0)
    (1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)

Note that comparing objects of different types with `<' or `>' is legal
provided that the objects have appropriate comparison methods.  For
example, mixed numeric types are compared according to their numeric
value, so 0 equals 0.0, etc.  Otherwise, rather than providing an
arbitrary ordering, the interpreter will raise a `TypeError' exception.


File: python-tutorial-3.2.2.info,  Node: Modules,  Next: Input and Output,  Prev: Data Structures,  Up: Top

6 Modules
*********

If you quit from the Python interpreter and enter it again, the
definitions you have made (functions and variables) are lost.
Therefore, if you want to write a somewhat longer program, you are
better off using a text editor to prepare the input for the interpreter
and running it with that file as input instead.  This is known as
creating a _script_.  As your program gets longer, you may want to
split it into several files for easier maintenance.  You may also want
to use a handy function that you've written in several programs without
copying its definition into each program.

  To support this, Python has a way to put definitions in a file and
use them in a script or in an interactive instance of the interpreter.
Such a file is called a _module_; definitions from a module can be
_imported_ into other modules or into the _main_ module (the collection
of variables that you have access to in a script executed at the top
level and in calculator mode).

  A module is a file containing Python definitions and statements.  The
file name is the module name with the suffix `.py' appended.  Within a
module, the module's name (as a string) is available as the value of
the global variable `__name__'.  For instance, use your favorite text
editor to create a file called `fibo.py' in the current directory with
the following contents:

    # Fibonacci numbers module

    def fib(n):    # write Fibonacci series up to n
        a, b = 0, 1
        while b < n:
            print(b, end=' ')
            a, b = b, a+b
        print()

    def fib2(n): # return Fibonacci series up to n
        result = []
        a, b = 0, 1
        while b < n:
            result.append(b)
            a, b = b, a+b
        return result

Now enter the Python interpreter and import this module with the
following command:

    >>> import fibo

This does not enter the names of the functions defined in `fibo'
directly in the current symbol table; it only enters the module name
`fibo' there. Using the module name you can access the functions:

    >>> fibo.fib(1000)
    1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
    >>> fibo.fib2(100)
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    >>> fibo.__name__
    'fibo'

If you intend to use a function often you can assign it to a local name:

    >>> fib = fibo.fib
    >>> fib(500)
    1 1 2 3 5 8 13 21 34 55 89 144 233 377


* Menu:

* More on Modules::
* Standard Modules::
* The dir() Function: The dir Function.
* Packages::

More on Modules

* Executing modules as scripts::
* The Module Search Path::
* "Compiled" Python files::

Packages

* Importing * From a Package::
* Intra-package References::
* Packages in Multiple Directories::


File: python-tutorial-3.2.2.info,  Node: More on Modules,  Next: Standard Modules,  Up: Modules

6.1 More on Modules
===================

A module can contain executable statements as well as function
definitions.  These statements are intended to initialize the module.
They are executed only the _first_ time the module is imported
somewhere. (1)

  Each module has its own private symbol table, which is used as the
global symbol table by all functions defined in the module. Thus, the
author of a module can use global variables in the module without
worrying about accidental clashes with a user's global variables. On
the other hand, if you know what you are doing you can touch a module's
global variables with the same notation used to refer to its functions,
`modname.itemname'.

  Modules can import other modules.  It is customary but not required
to place all `import' statements at the beginning of a module (or
script, for that matter).  The imported module names are placed in the
importing module's global symbol table.

  There is a variant of the `import' statement that imports names from a
module directly into the importing module's symbol table.  For example:

    >>> from fibo import fib, fib2
    >>> fib(500)
    1 1 2 3 5 8 13 21 34 55 89 144 233 377

This does not introduce the module name from which the imports are
taken in the local symbol table (so in the example, `fibo' is not
defined).

  There is even a variant to import all names that a module defines:

    >>> from fibo import *
    >>> fib(500)
    1 1 2 3 5 8 13 21 34 55 89 144 233 377

This imports all names except those beginning with an underscore (`_').
In most cases Python programmers do not use this facility since it
introduces an unknown set of names into the interpreter, possibly
hiding some things you have already defined.

  Note that in general the practice of importing `*' from a module or
package is frowned upon, since it often causes poorly readable code.
However, it is okay to use it to save typing in interactive sessions.

     Note: For efficiency reasons, each module is only imported once
     per interpreter session.  Therefore, if you change your modules,
     you must restart the interpreter - or, if it's just one module you
     want to test interactively, use `imp.reload()', e.g. `import imp;
     imp.reload(modulename)'.

* Menu:

* Executing modules as scripts::
* The Module Search Path::
* "Compiled" Python files::

  ---------- Footnotes ----------

  (1) In fact function definitions are also 'statements' that are
'executed'; the execution of a module-level function enters the
function name in the module's global symbol table.


File: python-tutorial-3.2.2.info,  Node: Executing modules as scripts,  Next: The Module Search Path,  Up: More on Modules

6.1.1 Executing modules as scripts
----------------------------------

When you run a Python module with

    python fibo.py <arguments>

the code in the module will be executed, just as if you imported it,
but with the `__name__' set to `"__main__"'.  That means that by adding
this code at the end of your module:

    if __name__ == "__main__":
        import sys
        fib(int(sys.argv[1]))

you can make the file usable as a script as well as an importable
module, because the code that parses the command line only runs if the
module is executed as the "main" file:

    $ python fibo.py 50
    1 1 2 3 5 8 13 21 34

If the module is imported, the code is not run:

    >>> import fibo
    >>>

This is often used either to provide a convenient user interface to a
module, or for testing purposes (running the module as a script
executes a test suite).


File: python-tutorial-3.2.2.info,  Node: The Module Search Path,  Next: "Compiled" Python files,  Prev: Executing modules as scripts,  Up: More on Modules

6.1.2 The Module Search Path
----------------------------

When a module named `spam' is imported, the interpreter searches for a
file named `spam.py' in the directory containing the input script and
then in the list of directories specified by the environment variable `PYTHONPATH'.
This has the same syntax as the shell variable `PATH', that is, a list
of directory names.  When `PYTHONPATH' is not set, or when the file is
not found there, the search continues in an installation-dependent
default path; on Unix, this is usually `.:/usr/local/lib/python'.

  Actually, modules are searched in the list of directories given by
the variable `sys.path' which is initialized from the directory
containing the input script (or the current directory), `PYTHONPATH'
and the installation- dependent default.  This allows Python programs
that know what they're doing to modify or replace the module search
path.  Note that because the directory containing the script being run
is on the search path, it is important that the script not have the
same name as a standard module, or Python will attempt to load the
script as a module when that module is imported. This will generally be
an error.  See section *note Standard Modules: 70. for more information.


File: python-tutorial-3.2.2.info,  Node: "Compiled" Python files,  Prev: The Module Search Path,  Up: More on Modules

6.1.3 "Compiled" Python files
-----------------------------

As an important speed-up of the start-up time for short programs that
use a lot of standard modules, if a file called `spam.pyc' exists in
the directory where `spam.py' is found, this is assumed to contain an
already-"byte-compiled" version of the module `spam'. The modification
time of the version of `spam.py' used to create `spam.pyc' is recorded
in `spam.pyc', and the `.pyc' file is ignored if these don't match.

  Normally, you don't need to do anything to create the `spam.pyc' file.
Whenever `spam.py' is successfully compiled, an attempt is made to write
the compiled version to `spam.pyc'.  It is not an error if this attempt
fails; if for any reason the file is not written completely, the
resulting `spam.pyc' file will be recognized as invalid and thus
ignored later.  The contents of the `spam.pyc' file are platform
independent, so a Python module directory can be shared by machines of
different architectures.

  Some tips for experts:

   * When the Python interpreter is invoked with the `-O' flag,
     optimized code is generated and stored in `.pyo' files.  The
     optimizer currently doesn't help much; it only removes `assert'
     statements.  When `-O' is used, _all_ _bytecode_ is optimized;
     `.pyc' files are ignored and `.py' files are compiled to optimized
     bytecode.

   * Passing two `-O' flags to the Python interpreter (`-OO') will
     cause the bytecode compiler to perform optimizations that could in
     some rare cases result in malfunctioning programs.  Currently only
     `__doc__' strings are removed from the bytecode, resulting in more
     compact `.pyo' files.  Since some programs may rely on having
     these available, you should only use this option if you know what
     you're doing.

   * A program doesn't run any faster when it is read from a `.pyc' or
     `.pyo' file than when it is read from a `.py' file; the only thing
     that's faster about `.pyc' or `.pyo' files is the speed with which
     they are loaded.

   * When a script is run by giving its name on the command line, the
     bytecode for the script is never written to a `.pyc' or `.pyo'
     file.  Thus, the startup time of a script may be reduced by moving
     most of its code to a module and having a small bootstrap script
     that imports that module.  It is also possible to name a `.pyc' or
     `.pyo' file directly on the command line.

   * It is possible to have a file called `spam.pyc' (or `spam.pyo'
     when `-O' is used) without a file `spam.py' for the same module.
     This can be used to distribute a library of Python code in a form
     that is moderately hard to reverse engineer.

   * The module `compileall' can create `.pyc' files (or `.pyo' files
     when `-O' is used) for all modules in a directory.


File: python-tutorial-3.2.2.info,  Node: Standard Modules,  Next: The dir Function,  Prev: More on Modules,  Up: Modules

6.2 Standard Modules
====================

Python comes with a library of standard modules, described in a separate
document, the Python Library Reference ("Library Reference" hereafter).
Some modules are built into the interpreter; these provide access to
operations that are not part of the core of the language but are
nevertheless built in, either for efficiency or to provide access to
operating system primitives such as system calls.  The set of such
modules is a configuration option which also depends on the underlying
platform For example, the `winreg' module is only provided on Windows
systems. One particular module deserves some attention: `sys', which is
built into every Python interpreter.  The variables `sys.ps1' and
`sys.ps2' define the strings used as primary and secondary prompts:

    >>> import sys
    >>> sys.ps1
    '>>> '
    >>> sys.ps2
    '... '
    >>> sys.ps1 = 'C> '
    C> print('Yuck!')
    Yuck!
    C>

These two variables are only defined if the interpreter is in
interactive mode.

  The variable `sys.path' is a list of strings that determines the
interpreter's search path for modules. It is initialized to a default
path taken from the environment variable `PYTHONPATH', or from a
built-in default if `PYTHONPATH' is not set.  You can modify it using
standard list operations:

    >>> import sys
    >>> sys.path.append('/ufs/guido/lib/python')



File: python-tutorial-3.2.2.info,  Node: The dir Function,  Next: Packages,  Prev: Standard Modules,  Up: Modules

6.3 The `dir()' Function
========================

The built-in function `dir()' is used to find out which names a module
defines.  It returns a sorted list of strings:

    >>> import fibo, sys
    >>> dir(fibo)
    ['__name__', 'fib', 'fib2']
    >>> dir(sys)
    ['__displayhook__', '__doc__', '__excepthook__', '__name__', '__stderr__',
     '__stdin__', '__stdout__', '_getframe', 'api_version', 'argv',
     'builtin_module_names', 'byteorder', 'callstats', 'copyright',
     'displayhook', 'exc_info', 'excepthook',
     'exec_prefix', 'executable', 'exit', 'getdefaultencoding', 'getdlopenflags',
     'getrecursionlimit', 'getrefcount', 'hexversion', 'maxint', 'maxunicode',
     'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache',
     'platform', 'prefix', 'ps1', 'ps2', 'setcheckinterval', 'setdlopenflags',
     'setprofile', 'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout',
     'version', 'version_info', 'warnoptions']

Without arguments, `dir()' lists the names you have defined currently:

    >>> a = [1, 2, 3, 4, 5]
    >>> import fibo
    >>> fib = fibo.fib
    >>> dir()
    ['__builtins__', '__doc__', '__file__', '__name__', 'a', 'fib', 'fibo', 'sys']

Note that it lists all types of names: variables, modules, functions,
etc.

  `dir()' does not list the names of built-in functions and variables.
If you want a list of those, they are defined in the standard module
`builtins':

    >>> import builtins
    >>> dir(builtins)

    ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'Buffer
    Error', 'BytesWarning', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'Environme
    ntError', 'Exception', 'False', 'FloatingPointError', 'FutureWarning', 'Generato
    rExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexErr
    or', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError',
     'None', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'P
    endingDeprecationWarning', 'ReferenceError', 'RuntimeError', 'RuntimeWarning', '
    StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'Ta
    bError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'Unicod
    eEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserW
    arning', 'ValueError', 'Warning', 'ZeroDivisionError', '__build_class__', '__deb
    ug__', '__doc__', '__import__', '__name__', '__package__', 'abs', 'all', 'any',
    'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'chr', 'classmethod', 'compile', '
    complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate
    ', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr',
    'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance',
     'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memory
    view', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property'
    , 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sort
    ed', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']



File: python-tutorial-3.2.2.info,  Node: Packages,  Prev: The dir Function,  Up: Modules

6.4 Packages
============

Packages are a way of structuring Python's module namespace by using
"dotted module names".  For example, the module name `A.B' designates a
submodule named `B' in a package named `A'.  Just like the use of
modules saves the authors of different modules from having to worry
about each other's global variable names, the use of dotted module
names saves the authors of multi-module packages like NumPy or the
Python Imaging Library from having to worry about each other's module
names.

  Suppose you want to design a collection of modules (a "package") for
the uniform handling of sound files and sound data.  There are many
different sound file formats (usually recognized by their extension,
for example: `.wav', `.aiff', `.au'), so you may need to create and
maintain a growing collection of modules for the conversion between the
various file formats.  There are also many different operations you
might want to perform on sound data (such as mixing, adding echo,
applying an equalizer function, creating an artificial stereo effect),
so in addition you will be writing a never-ending stream of modules to
perform these operations.  Here's a possible structure for your package
(expressed in terms of a hierarchical filesystem):

    sound/                          Top-level package
          __init__.py               Initialize the sound package
          formats/                  Subpackage for file format conversions
                  __init__.py
                  wavread.py
                  wavwrite.py
                  aiffread.py
                  aiffwrite.py
                  auread.py
                  auwrite.py
                  ...
          effects/                  Subpackage for sound effects
                  __init__.py
                  echo.py
                  surround.py
                  reverse.py
                  ...
          filters/                  Subpackage for filters
                  __init__.py
                  equalizer.py
                  vocoder.py
                  karaoke.py
                  ...

When importing the package, Python searches through the directories on
`sys.path' looking for the package subdirectory.

  The `__init__.py' files are required to make Python treat the
directories as containing packages; this is done to prevent directories
with a common name, such as `string', from unintentionally hiding valid
modules that occur later on the module search path. In the simplest
case, `__init__.py' can just be an empty file, but it can also execute
initialization code for the package or set the `__all__' variable,
described later.

  Users of the package can import individual modules from the package,
for example:

    import sound.effects.echo

This loads the submodule `sound.effects.echo'.  It must be referenced
with its full name.

    sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)

An alternative way of importing the submodule is:

    from sound.effects import echo

This also loads the submodule `echo', and makes it available without its
package prefix, so it can be used as follows:

    echo.echofilter(input, output, delay=0.7, atten=4)

Yet another variation is to import the desired function or variable
directly:

    from sound.effects.echo import echofilter

Again, this loads the submodule `echo', but this makes its function
`echofilter()' directly available:

    echofilter(input, output, delay=0.7, atten=4)

Note that when using `from package import item', the item can be either
a submodule (or subpackage) of the package, or some  other name defined
in the package, like a function, class or variable.  The `import'
statement first tests whether the item is defined in the package; if
not, it assumes it is a module and attempts to load it.  If it fails to
find it, an `ImportError' exception is raised.

  Contrarily, when using syntax like `import item.subitem.subsubitem',
each item except for the last must be a package; the last item can be a
module or a package but can't be a class or function or variable
defined in the previous item.

* Menu:

* Importing * From a Package::
* Intra-package References::
* Packages in Multiple Directories::


File: python-tutorial-3.2.2.info,  Node: Importing * From a Package,  Next: Intra-package References,  Up: Packages

6.4.1 Importing * From a Package
--------------------------------

Now what happens when the user writes `from sound.effects import *'?
Ideally, one would hope that this somehow goes out to the filesystem,
finds which submodules are present in the package, and imports them
all.  This could take a long time and importing sub-modules might have
unwanted side-effects that should only happen when the sub-module is
explicitly imported.

  The only solution is for the package author to provide an explicit
index of the package.  The `import' statement uses the following
convention: if a package's `__init__.py' code defines a list named
`__all__', it is taken to be the list of module names that should be
imported when `from package import *' is encountered.  It is up to the
package author to keep this list up-to-date when a new version of the
package is released.  Package authors may also decide not to support
it, if they don't see a use for importing * from their package.  For
example, the file `sounds/effects/__init__.py' could contain the
following code:

    __all__ = ["echo", "surround", "reverse"]

This would mean that `from sound.effects import *' would import the
three named submodules of the `sound' package.

  If `__all__' is not defined, the statement `from sound.effects import
*' does _not_ import all submodules from the package `sound.effects'
into the current namespace; it only ensures that the package
`sound.effects' has been imported (possibly running any initialization
code in `__init__.py') and then imports whatever names are defined in
the package.  This includes any names defined (and submodules
explicitly loaded) by `__init__.py'.  It also includes any submodules
of the package that were explicitly loaded by previous `import'
statements.  Consider this code:

    import sound.effects.echo
    import sound.effects.surround
    from sound.effects import *

In this example, the `echo' and `surround' modules are imported in the
current namespace because they are defined in the `sound.effects'
package when the `from...import' statement is executed.  (This also
works when `__all__' is defined.)

  Although certain modules are designed to export only names that
follow certain patterns when you use `import *', it is still considered
bad practise in production code.

  Remember, there is nothing wrong with using `from Package import
specific_submodule'!  In fact, this is the recommended notation unless
the importing module needs to use submodules with the same name from
different packages.


File: python-tutorial-3.2.2.info,  Node: Intra-package References,  Next: Packages in Multiple Directories,  Prev: Importing * From a Package,  Up: Packages

6.4.2 Intra-package References
------------------------------

When packages are structured into subpackages (as with the `sound'
package in the example), you can use absolute imports to refer to
submodules of siblings packages.  For example, if the module
`sound.filters.vocoder' needs to use the `echo' module in the
`sound.effects' package, it can use `from sound.effects import echo'.

  You can also write relative imports, with the `from module import
name' form of import statement.  These imports use leading dots to
indicate the current and parent packages involved in the relative
import.  From the `surround' module for example, you might use:

    from . import echo
    from .. import formats
    from ..filters import equalizer

Note that relative imports are based on the name of the current module.
Since the name of the main module is always `"__main__"', modules
intended for use as the main module of a Python application must always
use absolute imports.


File: python-tutorial-3.2.2.info,  Node: Packages in Multiple Directories,  Prev: Intra-package References,  Up: Packages

6.4.3 Packages in Multiple Directories
--------------------------------------

Packages support one more special attribute, `__path__'.  This is
initialized to be a list containing the name of the directory holding
the package's `__init__.py' before the code in that file is executed.
This variable can be modified; doing so affects future searches for
modules and subpackages contained in the package.

  While this feature is not often needed, it can be used to extend the
set of modules found in a package.


File: python-tutorial-3.2.2.info,  Node: Input and Output,  Next: Errors and Exceptions,  Prev: Modules,  Up: Top

7 Input and Output
******************

There are several ways to present the output of a program; data can be
printed in a human-readable form, or written to a file for future use.
This chapter will discuss some of the possibilities.

* Menu:

* Fancier Output Formatting::
* Reading and Writing Files::

Fancier Output Formatting

* Old string formatting::

Reading and Writing Files

* Methods of File Objects::
* The pickle Module::


File: python-tutorial-3.2.2.info,  Node: Fancier Output Formatting,  Next: Reading and Writing Files,  Up: Input and Output

7.1 Fancier Output Formatting
=============================

So far we've encountered two ways of writing values: _expression
statements_ and the `print()' function.  (A third way is using the
`write()' method of file objects; the standard output file can be
referenced as `sys.stdout'.  See the Library Reference for more
information on this.)

  Often you'll want more control over the formatting of your output
than simply printing space-separated values.  There are two ways to
format your output; the first way is to do all the string handling
yourself; using string slicing and concatenation operations you can
create any layout you can imagine.  The string type has some methods
that perform useful operations for padding strings to a given column
width; these will be discussed shortly.  The second way is to use the
`str.format()' method.

  The `string' module contains a `Template' class which offers yet
another way to substitute values into strings.

  One question remains, of course: how do you convert values to
strings? Luckily, Python has ways to convert any value to a string:
pass it to the `repr()' or `str()' functions.

  The `str()' function is meant to return representations of values
which are fairly human-readable, while `repr()' is meant to generate
representations which can be read by the interpreter (or will force a
`SyntaxError' if there is not equivalent syntax).  For objects which
don't have a particular representation for human consumption, `str()'
will return the same value as `repr()'.  Many values, such as numbers
or structures like lists and dictionaries, have the same representation
using either function.  Strings, in particular, have two distinct
representations.

  Some examples:

    >>> s = 'Hello, world.'
    >>> str(s)
    'Hello, world.'
    >>> repr(s)
    "'Hello, world.'"
    >>> str(1/7)
    '0.14285714285714285'
    >>> x = 10 * 3.25
    >>> y = 200 * 200
    >>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
    >>> print(s)
    The value of x is 32.5, and y is 40000...
    >>> # The repr() of a string adds string quotes and backslashes:
    ... hello = 'hello, world\n'
    >>> hellos = repr(hello)
    >>> print(hellos)
    'hello, world\n'
    >>> # The argument to repr() may be any Python object:
    ... repr((x, y, ('spam', 'eggs')))
    "(32.5, 40000, ('spam', 'eggs'))"

Here are two ways to write a table of squares and cubes:

    >>> for x in range(1, 11):
    ...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
    ...     # Note use of 'end' on previous line
    ...     print(repr(x*x*x).rjust(4))
    ...
     1   1    1
     2   4    8
     3   9   27
     4  16   64
     5  25  125
     6  36  216
     7  49  343
     8  64  512
     9  81  729
    10 100 1000

    >>> for x in range(1, 11):
    ...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
    ...
     1   1    1
     2   4    8
     3   9   27
     4  16   64
     5  25  125
     6  36  216
     7  49  343
     8  64  512
     9  81  729
    10 100 1000

(Note that in the first example, one space between each column was
added by the way `print()' works: it always adds spaces between its
arguments.)

  This example demonstrates the `str.rjust()' method of string objects,
which right-justifies a string in a field of a given width by padding
it with spaces on the left.  There are similar methods `str.ljust()' and
`str.center()'.  These methods do not write anything, they just return a
new string.  If the input string is too long, they don't truncate it,
but return it unchanged; this will mess up your column lay-out but
that's usually better than the alternative, which would be lying about
a value.  (If you really want truncation you can always add a slice
operation, as in `x.ljust(n)[:n]'.)

  There is another method, `str.zfill()', which pads a numeric string
on the left with zeros.  It understands about plus and minus signs:

    >>> '12'.zfill(5)
    '00012'
    >>> '-3.14'.zfill(7)
    '-003.14'
    >>> '3.14159265359'.zfill(5)
    '3.14159265359'

Basic usage of the `str.format()' method looks like this:

    >>> print('We are the {} who say "{}!"'.format('knights', 'Ni'))
    We are the knights who say "Ni!"

The brackets and characters within them (called format fields) are
replaced with the objects passed into the `str.format()' method.  A
number in the brackets can be used to refer to the position of the
object passed into the `str.format()' method.

    >>> print('{0} and {1}'.format('spam', 'eggs'))
    spam and eggs
    >>> print('{1} and {0}'.format('spam', 'eggs'))
    eggs and spam

If keyword arguments are used in the `str.format()' method, their values
are referred to by using the name of the argument.

    >>> print('This {food} is {adjective}.'.format(
    ...       food='spam', adjective='absolutely horrible'))
    This spam is absolutely horrible.

Positional and keyword arguments can be arbitrarily combined:

    >>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
                                                           other='Georg'))
    The story of Bill, Manfred, and Georg.

`'!a'' (apply `ascii()'), `'!s'' (apply `str()') and `'!r'' (apply
`repr()') can be used to convert the value before it is formatted:

    >>> import math
    >>> print('The value of PI is approximately {}.'.format(math.pi))
    The value of PI is approximately 3.14159265359.
    >>> print('The value of PI is approximately {!r}.'.format(math.pi))
    The value of PI is approximately 3.141592653589793.

An optional `':'' and format specifier can follow the field name. This
allows greater control over how the value is formatted.  The following
example rounds Pi to three places after the decimal.

    >>> import math
    >>> print('The value of PI is approximately {0:.3f}.'.format(math.pi))
    The value of PI is approximately 3.142.

Passing an integer after the `':'' will cause that field to be a minimum
number of characters wide.  This is useful for making tables pretty.

    >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
    >>> for name, phone in table.items():
    ...     print('{0:10} ==> {1:10d}'.format(name, phone))
    ...
    Jack       ==>       4098
    Dcab       ==>       7678
    Sjoerd     ==>       4127

If you have a really long format string that you don't want to split
up, it would be nice if you could reference the variables to be
formatted by name instead of by position.  This can be done by simply
passing the dict and using square brackets `'[]'' to access the keys

    >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
    >>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
              'Dcab: {0[Dcab]:d}'.format(table))
    Jack: 4098; Sjoerd: 4127; Dcab: 8637678

This could also be done by passing the table as keyword arguments with
the '**' notation.

    >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
    >>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
    Jack: 4098; Sjoerd: 4127; Dcab: 8637678

This is particularly useful in combination with the built-in function
`vars()', which returns a dictionary containing all local variables.

  For a complete overview of string formatting with `str.format()', see
_formatstrings_.

* Menu:

* Old string formatting::


File: python-tutorial-3.2.2.info,  Node: Old string formatting,  Up: Fancier Output Formatting

7.1.1 Old string formatting
---------------------------

The `%' operator can also be used for string formatting. It interprets
the left argument much like a `sprintf()'-style format string to be
applied to the right argument, and returns the string resulting from
this formatting operation. For example:

    >>> import math
    >>> print('The value of PI is approximately %5.3f.' % math.pi)
    The value of PI is approximately 3.142.

Since `str.format()' is quite new, a lot of Python code still uses the
`%' operator. However, because this old style of formatting will
eventually be removed from the language, `str.format()' should
generally be used.

  More information can be found in the _old-string-formatting_ section.


File: python-tutorial-3.2.2.info,  Node: Reading and Writing Files,  Prev: Fancier Output Formatting,  Up: Input and Output

7.2 Reading and Writing Files
=============================

`open()' returns a _file object_, and is most commonly used with two
arguments: `open(filename, mode)'.

    >>> f = open('/tmp/workfile', 'w')


  The first argument is a string containing the filename.  The second
argument is another string containing a few characters describing the
way in which the file will be used.  _mode_ can be `'r'' when the file
will only be read, `'w'' for only writing (an existing file with the
same name will be erased), and `'a'' opens the file for appending; any
data written to the file is automatically added to the end.  `'r+''
opens the file for both reading and writing. The _mode_ argument is
optional; `'r'' will be assumed if it's omitted.

  Normally, files are opened in _text mode_, that means, you read and
write strings from and to the file, which are encoded in a specific
encoding (the default being UTF-8).  `'b'' appended to the mode opens
the file in _binary mode_: now the data is read and written in the form
of bytes objects.  This mode should be used for all files that don't
contain text.

  In text mode, the default is to convert platform-specific line
endings (`\n' on Unix, `\r\n' on Windows) to just `\n' on reading and
`\n' back to platform-specific line endings on writing.  This
behind-the-scenes modification to file data is fine for text files, but
will corrupt binary data like that in `JPEG' or `EXE' files.  Be very
careful to use binary mode when reading and writing such files.

* Menu:

* Methods of File Objects::
* The pickle Module::


File: python-tutorial-3.2.2.info,  Node: Methods of File Objects,  Next: The pickle Module,  Up: Reading and Writing Files

7.2.1 Methods of File Objects
-----------------------------

The rest of the examples in this section will assume that a file object
called `f' has already been created.

  To read a file's contents, call `f.read(size)', which reads some
quantity of data and returns it as a string or bytes object.  _size_ is
an optional numeric argument.  When _size_ is omitted or negative, the
entire contents of the file will be read and returned; it's your
problem if the file is twice as large as your machine's memory.
Otherwise, at most _size_ bytes are read and returned.  If the end of
the file has been reached, `f.read()' will return an empty string
(`''').

    >>> f.read()
    'This is the entire file.\n'
    >>> f.read()
    ''

`f.readline()' reads a single line from the file; a newline character
(`\n') is left at the end of the string, and is only omitted on the
last line of the file if the file doesn't end in a newline.  This makes
the return value unambiguous; if `f.readline()' returns an empty
string, the end of the file has been reached, while a blank line is
represented by `'\n'', a string containing only a single newline.

    >>> f.readline()
    'This is the first line of the file.\n'
    >>> f.readline()
    'Second line of the file\n'
    >>> f.readline()
    ''

`f.readlines()' returns a list containing all the lines of data in the
file.  If given an optional parameter _sizehint_, it reads that many
bytes from the file and enough more to complete a line, and returns the
lines from that.  This is often used to allow efficient reading of a
large file by lines, but without having to load the entire file in
memory.  Only complete lines will be returned.

    >>> f.readlines()
    ['This is the first line of the file.\n', 'Second line of the file\n']

An alternative approach to reading lines is to loop over the file
object. This is memory efficient, fast, and leads to simpler code:

    >>> for line in f:
    ...     print(line, end='')
    ...
    This is the first line of the file.
    Second line of the file

The alternative approach is simpler but does not provide as fine-grained
control.  Since the two approaches manage line buffering differently,
they should not be mixed.

  `f.write(string)' writes the contents of _string_ to the file,
returning the number of characters written.

    >>> f.write('This is a test\n')
    15

To write something other than a string, it needs to be converted to a
string first:

    >>> value = ('the answer', 42)
    >>> s = str(value)
    >>> f.write(s)
    18

`f.tell()' returns an integer giving the file object's current position
in the file, measured in bytes from the beginning of the file.  To
change the file object's position, use `f.seek(offset, from_what)'.
The position is computed from adding _offset_ to a reference point; the
reference point is selected by the _from_what_ argument.  A _from_what_
value of 0 measures from the beginning of the file, 1 uses the current
file position, and 2 uses the end of the file as the reference point.
_from_what_ can be omitted and defaults to 0, using the beginning of
the file as the reference point.

    >>> f = open('/tmp/workfile', 'rb+')
    >>> f.write(b'0123456789abcdef')
    16
    >>> f.seek(5)     # Go to the 6th byte in the file
    5
    >>> f.read(1)
    b'5'
    >>> f.seek(-3, 2) # Go to the 3rd byte before the end
    13
    >>> f.read(1)
    b'd'

In text files (those opened without a `b' in the mode string), only
seeks relative to the beginning of the file are allowed (the exception
being seeking to the very file end with `seek(0, 2)').

  When you're done with a file, call `f.close()' to close it and free
up any system resources taken up by the open file.  After calling
`f.close()', attempts to use the file object will automatically fail.

    >>> f.close()
    >>> f.read()
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    ValueError: I/O operation on closed file

It is good practice to use the `with' keyword when dealing with file
objects.  This has the advantage that the file is properly closed after
its suite finishes, even if an exception is raised on the way.  It is
also much shorter than writing equivalent `try'-`finally' blocks:

    >>> with open('/tmp/workfile', 'r') as f:
    ...     read_data = f.read()
    >>> f.closed
    True

File objects have some additional methods, such as `isatty()' and
`truncate()' which are less frequently used; consult the Library
Reference for a complete guide to file objects.


File: python-tutorial-3.2.2.info,  Node: The pickle Module,  Prev: Methods of File Objects,  Up: Reading and Writing Files

7.2.2 The `pickle' Module
-------------------------

Strings can easily be written to and read from a file. Numbers take a
bit more effort, since the `read()' method only returns strings, which
will have to be passed to a function like `int()', which takes a string
like `'123'' and returns its numeric value 123.  However, when you want
to save more complex data types like lists, dictionaries, or class
instances, things get a lot more complicated.

  Rather than have users be constantly writing and debugging code to
save complicated data types, Python provides a standard module called
`pickle'.  This is an amazing module that can take almost any Python
object (even some forms of Python code!), and convert it to a string
representation; this process is called _pickling_.  Reconstructing the
object from the string representation is called _unpickling_.  Between
pickling and unpickling, the string representing the object may have
been stored in a file or data, or sent over a network connection to
some distant machine.

  If you have an object `x', and a file object `f' that's been opened
for writing, the simplest way to pickle the object takes only one line
of code:

    pickle.dump(x, f)

To unpickle the object again, if `f' is a file object which has been
opened for reading:

    x = pickle.load(f)

(There are other variants of this, used when pickling many objects or
when you don't want to write the pickled data to a file; consult the
complete documentation for `pickle' in the Python Library Reference.)

  `pickle' is the standard way to make Python objects which can be
stored and reused by other programs or by a future invocation of the
same program; the technical term for this is a _persistent_ object.
Because `pickle' is so widely used, many authors who write Python
extensions take care to ensure that new data types such as matrices can
be properly pickled and unpickled.


File: python-tutorial-3.2.2.info,  Node: Errors and Exceptions,  Next: Classes,  Prev: Input and Output,  Up: Top

8 Errors and Exceptions
***********************

Until now error messages haven't been more than mentioned, but if you
have tried out the examples you have probably seen some.  There are (at
least) two distinguishable kinds of errors: _syntax errors_ and
_exceptions_.

* Menu:

* Syntax Errors::
* Exceptions::
* Handling Exceptions::
* Raising Exceptions::
* User-defined Exceptions::
* Defining Clean-up Actions::
* Predefined Clean-up Actions::


File: python-tutorial-3.2.2.info,  Node: Syntax Errors,  Next: Exceptions,  Up: Errors and Exceptions

8.1 Syntax Errors
=================

Syntax errors, also known as parsing errors, are perhaps the most
common kind of complaint you get while you are still learning Python:

    >>> while True print('Hello world')
      File "<stdin>", line 1, in ?
        while True print('Hello world')
                       ^
    SyntaxError: invalid syntax

The parser repeats the offending line and displays a little 'arrow'
pointing at the earliest point in the line where the error was
detected.  The error is caused by (or at least detected at) the token
_preceding_ the arrow: in the example, the error is detected at the
function `print()', since a colon (`':'') is missing before it.  File
name and line number are printed so you know where to look in case the
input came from a script.


File: python-tutorial-3.2.2.info,  Node: Exceptions,  Next: Handling Exceptions,  Prev: Syntax Errors,  Up: Errors and Exceptions

8.2 Exceptions
==============

Even if a statement or expression is syntactically correct, it may
cause an error when an attempt is made to execute it. Errors detected
during execution are called _exceptions_ and are not unconditionally
fatal: you will soon learn how to handle them in Python programs.  Most
exceptions are not handled by programs, however, and result in error
messages as shown here:

    >>> 10 * (1/0)
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    ZeroDivisionError: int division or modulo by zero
    >>> 4 + spam*3
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    NameError: name 'spam' is not defined
    >>> '2' + 2
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: Can't convert 'int' object to str implicitly

The last line of the error message indicates what happened. Exceptions
come in different types, and the type is printed as part of the
message: the types in the example are `ZeroDivisionError', `NameError'
and `TypeError'.  The string printed as the exception type is the name
of the built-in exception that occurred.  This is true for all built-in
exceptions, but need not be true for user-defined exceptions (although
it is a useful convention). Standard exception names are built-in
identifiers (not reserved keywords).

  The rest of the line provides detail based on the type of exception
and what caused it.

  The preceding part of the error message shows the context where the
exception happened, in the form of a stack traceback. In general it
contains a stack traceback listing source lines; however, it will not
display lines read from standard input.

  _bltin-exceptions_ lists the built-in exceptions and their meanings.


File: python-tutorial-3.2.2.info,  Node: Handling Exceptions,  Next: Raising Exceptions,  Prev: Exceptions,  Up: Errors and Exceptions

8.3 Handling Exceptions
=======================

It is possible to write programs that handle selected exceptions. Look
at the following example, which asks the user for input until a valid
integer has been entered, but allows the user to interrupt the program
(using `Control-C' or whatever the operating system supports); note
that a user-generated interruption is signalled by raising the
`KeyboardInterrupt' exception.

    >>> while True:
    ...     try:
    ...         x = int(input("Please enter a number: "))
    ...         break
    ...     except ValueError:
    ...         print("Oops!  That was no valid number.  Try again...")
    ...

The `try' statement works as follows.

   * First, the _try clause_ (the statement(s) between the `try' and
     `except' keywords) is executed.

   * If no exception occurs, the _except clause_ is skipped and
     execution of the `try' statement is finished.

   * If an exception occurs during execution of the try clause, the
     rest of the clause is skipped.  Then if its type matches the
     exception named after the `except' keyword, the except clause is
     executed, and then execution continues after the `try' statement.

   * If an exception occurs which does not match the exception named in
     the except clause, it is passed on to outer `try' statements; if
     no handler is found, it is an _unhandled exception_ and execution
     stops with a message as shown above.

  A `try' statement may have more than one except clause, to specify
handlers for different exceptions.  At most one handler will be
executed.  Handlers only handle exceptions that occur in the
corresponding try clause, not in other handlers of the same `try'
statement.  An except clause may name multiple exceptions as a
parenthesized tuple, for example:

    ... except (RuntimeError, TypeError, NameError):
    ...     pass

The last except clause may omit the exception name(s), to serve as a
wildcard.  Use this with extreme caution, since it is easy to mask a
real programming error in this way!  It can also be used to print an
error message and then re-raise the exception (allowing a caller to
handle the exception as well):

    import sys

    try:
        f = open('myfile.txt')
        s = f.readline()
        i = int(s.strip())
    except IOError as err:
        print("I/O error: {0}".format(err))
    except ValueError:
        print("Could not convert data to an integer.")
    except:
        print("Unexpected error:", sys.exc_info()[0])
        raise

The `try' ... `except' statement has an optional _else clause_, which,
when present, must follow all except clauses.  It is useful for code
that must be executed if the try clause does not raise an exception.
For example:

    for arg in sys.argv[1:]:
        try:
            f = open(arg, 'r')
        except IOError:
            print('cannot open', arg)
        else:
            print(arg, 'has', len(f.readlines()), 'lines')
            f.close()

The use of the `else' clause is better than adding additional code to
the `try' clause because it avoids accidentally catching an exception
that wasn't raised by the code being protected by the `try' ...
`except' statement.

  When an exception occurs, it may have an associated value, also known
as the exception's _argument_. The presence and type of the argument
depend on the exception type.

  The except clause may specify a variable after the exception name.
The variable is bound to an exception instance with the arguments
stored in `instance.args'.  For convenience, the exception instance
defines `__str__()' so the arguments can be printed directly without
having to reference `.args'.  One may also instantiate an exception
first before raising it and add any attributes to it as desired.

    >>> try:
    ...    raise Exception('spam', 'eggs')
    ... except Exception as inst:
    ...    print(type(inst))    # the exception instance
    ...    print(inst.args)     # arguments stored in .args
    ...    print(inst)          # __str__ allows args to be printed directly,
    ...                         # but may be overridden in exception subclasses
    ...    x, y = inst.args     # unpack args
    ...    print('x =', x)
    ...    print('y =', y)
    ...
    <class 'Exception'>
    ('spam', 'eggs')
    ('spam', 'eggs')
    x = spam
    y = eggs

If an exception has arguments, they are printed as the last part
('detail') of the message for unhandled exceptions.

  Exception handlers don't just handle exceptions if they occur
immediately in the try clause, but also if they occur inside functions
that are called (even indirectly) in the try clause. For example:

    >>> def this_fails():
    ...     x = 1/0
    ...
    >>> try:
    ...     this_fails()
    ... except ZeroDivisionError as err:
    ...     print('Handling run-time error:', err)
    ...
    Handling run-time error: int division or modulo by zero



File: python-tutorial-3.2.2.info,  Node: Raising Exceptions,  Next: User-defined Exceptions,  Prev: Handling Exceptions,  Up: Errors and Exceptions

8.4 Raising Exceptions
======================

The `raise' statement allows the programmer to force a specified
exception to occur. For example:

    >>> raise NameError('HiThere')
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    NameError: HiThere

The sole argument to `raise' indicates the exception to be raised.
This must be either an exception instance or an exception class (a
class that derives from `Exception').

  If you need to determine whether an exception was raised but don't
intend to handle it, a simpler form of the `raise' statement allows you
to re-raise the exception:

    >>> try:
    ...     raise NameError('HiThere')
    ... except NameError:
    ...     print('An exception flew by!')
    ...     raise
    ...
    An exception flew by!
    Traceback (most recent call last):
      File "<stdin>", line 2, in ?
    NameError: HiThere



File: python-tutorial-3.2.2.info,  Node: User-defined Exceptions,  Next: Defining Clean-up Actions,  Prev: Raising Exceptions,  Up: Errors and Exceptions

8.5 User-defined Exceptions
===========================

Programs may name their own exceptions by creating a new exception
class (see *note Classes: 3d. for more about Python classes).
Exceptions should typically be derived from the `Exception' class,
either directly or indirectly.  For example:

    >>> class MyError(Exception):
    ...     def __init__(self, value):
    ...         self.value = value
    ...     def __str__(self):
    ...         return repr(self.value)
    ...
    >>> try:
    ...     raise MyError(2*2)
    ... except MyError as e:
    ...     print('My exception occurred, value:', e.value)
    ...
    My exception occurred, value: 4
    >>> raise MyError('oops!')
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    __main__.MyError: 'oops!'

In this example, the default `__init__()' of `Exception' has been
overridden.  The new behavior simply creates the _value_ attribute.
This replaces the default behavior of creating the _args_ attribute.

  Exception classes can be defined which do anything any other class
can do, but are usually kept simple, often only offering a number of
attributes that allow information about the error to be extracted by
handlers for the exception.  When creating a module that can raise
several distinct errors, a common practice is to create a base class
for exceptions defined by that module, and subclass that to create
specific exception classes for different error conditions:

    class Error(Exception):
        """Base class for exceptions in this module."""
        pass

    class InputError(Error):
        """Exception raised for errors in the input.

        Attributes:
            expression -- input expression in which the error occurred
            message -- explanation of the error
        """

        def __init__(self, expression, message):
            self.expression = expression
            self.message = message

    class TransitionError(Error):
        """Raised when an operation attempts a state transition that's not
        allowed.

        Attributes:
            previous -- state at beginning of transition
            next -- attempted new state
            message -- explanation of why the specific transition is not allowed
        """

        def __init__(self, previous, next, message):
            self.previous = previous
            self.next = next
            self.message = message

Most exceptions are defined with names that end in "Error," similar to
the naming of the standard exceptions.

  Many standard modules define their own exceptions to report errors
that may occur in functions they define.  More information on classes
is presented in chapter *note Classes: 3d.


File: python-tutorial-3.2.2.info,  Node: Defining Clean-up Actions,  Next: Predefined Clean-up Actions,  Prev: User-defined Exceptions,  Up: Errors and Exceptions

8.6 Defining Clean-up Actions
=============================

The `try' statement has another optional clause which is intended to
define clean-up actions that must be executed under all circumstances.
For example:

    >>> try:
    ...     raise KeyboardInterrupt
    ... finally:
    ...     print('Goodbye, world!')
    ...
    Goodbye, world!
    Traceback (most recent call last):
      File "<stdin>", line 2, in ?
    KeyboardInterrupt

A _finally clause_ is always executed before leaving the `try'
statement, whether an exception has occurred or not. When an exception
has occurred in the `try' clause and has not been handled by an
`except' clause (or it has occurred in a `except' or `else' clause), it
is re-raised after the `finally' clause has been executed.  The
`finally' clause is also executed "on the way out" when any other
clause of the `try' statement is left via a `break', `continue' or
`return' statement.  A more complicated example:

    >>> def divide(x, y):
    ...     try:
    ...         result = x / y
    ...     except ZeroDivisionError:
    ...         print("division by zero!")
    ...     else:
    ...         print("result is", result)
    ...     finally:
    ...         print("executing finally clause")
    ...
    >>> divide(2, 1)
    result is 2.0
    executing finally clause
    >>> divide(2, 0)
    division by zero!
    executing finally clause
    >>> divide("2", "1")
    executing finally clause
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
      File "<stdin>", line 3, in divide
    TypeError: unsupported operand type(s) for /: 'str' and 'str'

As you can see, the `finally' clause is executed in any event.  The
`TypeError' raised by dividing two strings is not handled by the
`except' clause and therefore re-raised after the `finally' clause has
been executed.

  In real world applications, the `finally' clause is useful for
releasing external resources (such as files or network connections),
regardless of whether the use of the resource was successful.


File: python-tutorial-3.2.2.info,  Node: Predefined Clean-up Actions,  Prev: Defining Clean-up Actions,  Up: Errors and Exceptions

8.7 Predefined Clean-up Actions
===============================

Some objects define standard clean-up actions to be undertaken when the
object is no longer needed, regardless of whether or not the operation
using the object succeeded or failed. Look at the following example,
which tries to open a file and print its contents to the screen.

    for line in open("myfile.txt"):
        print(line)

The problem with this code is that it leaves the file open for an
indeterminate amount of time after this part of the code has finished
executing.  This is not an issue in simple scripts, but can be a
problem for larger applications. The `with' statement allows objects
like files to be used in a way that ensures they are always cleaned up
promptly and correctly.

    with open("myfile.txt") as f:
        for line in f:
            print(line)

After the statement is executed, the file _f_ is always closed, even if
a problem was encountered while processing the lines. Objects which,
like files, provide predefined clean-up actions will indicate this in
their documentation.


File: python-tutorial-3.2.2.info,  Node: Classes,  Next: Brief Tour of the Standard Library,  Prev: Errors and Exceptions,  Up: Top

9 Classes
*********

Compared with other programming languages, Python's class mechanism
adds classes with a minimum of new syntax and semantics.  It is a
mixture of the class mechanisms found in C++ and Modula-3.  Python
classes provide all the standard features of Object Oriented
Programming: the class inheritance mechanism allows multiple base
classes, a derived class can override any methods of its base class or
classes, and a method can call the method of a base class with the same
name.  Objects can contain arbitrary amounts and kinds of data.  As is
true for modules, classes partake of the dynamic nature of Python: they
are created at runtime, and can be modified further after creation.

  In C++ terminology, normally class members (including the data
members) are _public_ (except see below *note Private Variables: 9a.),
and all member functions are _virtual_.  As in Modula-3, there are no
shorthands for referencing the object's members from its methods: the
method function is declared with an explicit first argument
representing the object, which is provided implicitly by the call.  As
in Smalltalk, classes themselves are objects.  This provides semantics
for importing and renaming.  Unlike C++ and Modula-3, built-in types
can be used as base classes for extension by the user.  Also, like in
C++, most built-in operators with special syntax (arithmetic operators,
subscripting etc.) can be redefined for class instances.

  (Lacking universally accepted terminology to talk about classes, I
will make occasional use of Smalltalk and C++ terms.  I would use
Modula-3 terms, since its object-oriented semantics are closer to those
of Python than C++, but I expect that few readers have heard of it.)

* Menu:

* A Word About Names and Objects::
* Python Scopes and Namespaces::
* A First Look at Classes::
* Random Remarks::
* Inheritance::
* Private Variables::
* Odds and Ends::
* Exceptions Are Classes Too::
* Iterators::
* Generators::
* Generator Expressions::


File: python-tutorial-3.2.2.info,  Node: A Word About Names and Objects,  Next: Python Scopes and Namespaces,  Up: Classes

9.1 A Word About Names and Objects
==================================

Objects have individuality, and multiple names (in multiple scopes) can
be bound to the same object.  This is known as aliasing in other
languages.  This is usually not appreciated on a first glance at
Python, and can be safely ignored when dealing with immutable basic
types (numbers, strings, tuples).  However, aliasing has a possibly
surprising effect on the semantics of Python code involving mutable
objects such as lists, dictionaries, and most other types.  This is
usually used to the benefit of the program, since aliases behave like
pointers in some respects.  For example, passing an object is cheap
since only a pointer is passed by the implementation; and if a function
modifies an object passed as an argument, the caller will see the
change -- this eliminates the need for two different argument passing
mechanisms as in Pascal.


File: python-tutorial-3.2.2.info,  Node: Python Scopes and Namespaces,  Next: A First Look at Classes,  Prev: A Word About Names and Objects,  Up: Classes

9.2 Python Scopes and Namespaces
================================

Before introducing classes, I first have to tell you something about
Python's scope rules.  Class definitions play some neat tricks with
namespaces, and you need to know how scopes and namespaces work to
fully understand what's going on.  Incidentally, knowledge about this
subject is useful for any advanced Python programmer.

  Let's begin with some definitions.

  A _namespace_ is a mapping from names to objects.  Most namespaces
are currently implemented as Python dictionaries, but that's normally
not noticeable in any way (except for performance), and it may change
in the future.  Examples of namespaces are: the set of built-in names
(containing functions such as `abs()', and built-in exception names);
the global names in a module; and the local names in a function
invocation.  In a sense the set of attributes of an object also form a
namespace.  The important thing to know about namespaces is that there
is absolutely no relation between names in different namespaces; for
instance, two different modules may both define a function `maximize'
without confusion -- users of the modules must prefix it with the
module name.

  By the way, I use the word _attribute_ for any name following a dot
-- for example, in the expression `z.real', `real' is an attribute of
the object `z'.  Strictly speaking, references to names in modules are
attribute references: in the expression `modname.funcname', `modname'
is a module object and `funcname' is an attribute of it.  In this case
there happens to be a straightforward mapping between the module's
attributes and the global names defined in the module: they share the
same namespace!  (1)

  Attributes may be read-only or writable.  In the latter case,
assignment to attributes is possible.  Module attributes are writable:
you can write `modname.the_answer = 42'.  Writable attributes may also
be deleted with the `del' statement.  For example, `del
modname.the_answer' will remove the attribute `the_answer' from the
object named by `modname'.

  Namespaces are created at different moments and have different
lifetimes.  The namespace containing the built-in names is created when
the Python interpreter starts up, and is never deleted.  The global
namespace for a module is created when the module definition is read
in; normally, module namespaces also last until the interpreter quits.
The statements executed by the top-level invocation of the interpreter,
either read from a script file or interactively, are considered part of
a module called `__main__', so they have their own global namespace.
(The built-in names actually also live in a module; this is called
`builtins'.)

  The local namespace for a function is created when the function is
called, and deleted when the function returns or raises an exception
that is not handled within the function.  (Actually, forgetting would
be a better way to describe what actually happens.)  Of course,
recursive invocations each have their own local namespace.

  A _scope_ is a textual region of a Python program where a namespace
is directly accessible.  "Directly accessible" here means that an
unqualified reference to a name attempts to find the name in the
namespace.

  Although scopes are determined statically, they are used dynamically.
At any time during execution, there are at least three nested scopes
whose namespaces are directly accessible:

   * the innermost scope, which is searched first, contains the local
     names

   * the scopes of any enclosing functions, which are searched starting
     with the nearest enclosing scope, contains non-local, but also
     non-global names

   * the next-to-last scope contains the current module's global names

   * the outermost scope (searched last) is the namespace containing
     built-in names

  If a name is declared global, then all references and assignments go
directly to the middle scope containing the module's global names.  To
rebind variables found outside of the innermost scope, the `nonlocal'
statement can be used; if not declared nonlocal, those variable are
read-only (an attempt to write to such a variable will simply create a
_new_ local variable in the innermost scope, leaving the identically
named outer variable unchanged).

  Usually, the local scope references the local names of the
(textually) current function.  Outside functions, the local scope
references the same namespace as the global scope: the module's
namespace. Class definitions place yet another namespace in the local
scope.

  It is important to realize that scopes are determined textually: the
global scope of a function defined in a module is that module's
namespace, no matter from where or by what alias the function is
called.  On the other hand, the actual search for names is done
dynamically, at run time -- however, the language definition is
evolving towards static name resolution, at "compile" time, so don't
rely on dynamic name resolution!  (In fact, local variables are already
determined statically.)

  A special quirk of Python is that - if no `global' statement is in
effect - assignments to names always go into the innermost scope.
Assignments do not copy data -- they just bind names to objects.  The
same is true for deletions: the statement `del x' removes the binding
of `x' from the namespace referenced by the local scope.  In fact, all
operations that introduce new names use the local scope: in particular,
`import' statements and function definitions bind the module or
function name in the local scope.

  The `global' statement can be used to indicate that particular
variables live in the global scope and should be rebound there; the
`nonlocal' statement indicates that particular variables live in an
enclosing scope and should be rebound there.

* Menu:

* Scopes and Namespaces Example::

  ---------- Footnotes ----------

  (1) Except for one thing.  Module objects have a secret read-only
attribute called `__dict__' which returns the dictionary used to
implement the module's namespace; the name `__dict__' is an attribute
but not a global name.  Obviously, using this violates the abstraction
of namespace implementation, and should be restricted to things like
post-mortem debuggers.


File: python-tutorial-3.2.2.info,  Node: Scopes and Namespaces Example,  Up: Python Scopes and Namespaces

9.2.1 Scopes and Namespaces Example
-----------------------------------

This is an example demonstrating how to reference the different scopes
and namespaces, and how `global' and `nonlocal' affect variable binding:

    def scope_test():
        def do_local():
            spam = "local spam"
        def do_nonlocal():
            nonlocal spam
            spam = "nonlocal spam"
        def do_global():
            global spam
            spam = "global spam"

        spam = "test spam"
        do_local()
        print("After local assignment:", spam)
        do_nonlocal()
        print("After nonlocal assignment:", spam)
        do_global()
        print("After global assignment:", spam)

    scope_test()
    print("In global scope:", spam)

The output of the example code is:

    After local assignment: test spam
    After nonlocal assignment: nonlocal spam
    After global assignment: nonlocal spam
    In global scope: global spam

Note how the _local_ assignment (which is default) didn't change
_scope_test_'s binding of _spam_.  The `nonlocal' assignment changed
_scope_test_'s binding of _spam_, and the `global' assignment changed
the module-level binding.

  You can also see that there was no previous binding for _spam_ before
the `global' assignment.


File: python-tutorial-3.2.2.info,  Node: A First Look at Classes,  Next: Random Remarks,  Prev: Python Scopes and Namespaces,  Up: Classes

9.3 A First Look at Classes
===========================

Classes introduce a little bit of new syntax, three new object types,
and some new semantics.

* Menu:

* Class Definition Syntax::
* Class Objects::
* Instance Objects::
* Method Objects::


File: python-tutorial-3.2.2.info,  Node: Class Definition Syntax,  Next: Class Objects,  Up: A First Look at Classes

9.3.1 Class Definition Syntax
-----------------------------

The simplest form of class definition looks like this:

    class ClassName:
        <statement-1>
        .
        .
        .
        <statement-N>

Class definitions, like function definitions (`def' statements) must be
executed before they have any effect.  (You could conceivably place a
class definition in a branch of an `if' statement, or inside a
function.)

  In practice, the statements inside a class definition will usually be
function definitions, but other statements are allowed, and sometimes
useful -- we'll come back to this later.  The function definitions
inside a class normally have a peculiar form of argument list, dictated
by the calling conventions for methods -- again, this is explained
later.

  When a class definition is entered, a new namespace is created, and
used as the local scope -- thus, all assignments to local variables go
into this new namespace.  In particular, function definitions bind the
name of the new function here.

  When a class definition is left normally (via the end), a _class
object_ is created.  This is basically a wrapper around the contents of
the namespace created by the class definition; we'll learn more about
class objects in the next section.  The original local scope (the one
in effect just before the class definition was entered) is reinstated,
and the class object is bound here to the class name given in the class
definition header (`ClassName' in the example).


File: python-tutorial-3.2.2.info,  Node: Class Objects,  Next: Instance Objects,  Prev: Class Definition Syntax,  Up: A First Look at Classes

9.3.2 Class Objects
-------------------

Class objects support two kinds of operations: attribute references and
instantiation.

  _Attribute references_ use the standard syntax used for all attribute
references in Python: `obj.name'.  Valid attribute names are all the
names that were in the class's namespace when the class object was
created.  So, if the class definition looked like this:

    class MyClass:
        """A simple example class"""
        i = 12345
        def f(self):
            return 'hello world'

then `MyClass.i' and `MyClass.f' are valid attribute references,
returning an integer and a function object, respectively. Class
attributes can also be assigned to, so you can change the value of
`MyClass.i' by assignment.  `__doc__' is also a valid attribute,
returning the docstring belonging to the class: `"A simple example
class"'.

  Class _instantiation_ uses function notation.  Just pretend that the
class object is a parameterless function that returns a new instance of
the class.  For example (assuming the above class):

    x = MyClass()

creates a new _instance_ of the class and assigns this object to the
local variable `x'.

  The instantiation operation ("calling" a class object) creates an
empty object.  Many classes like to create objects with instances
customized to a specific initial state. Therefore a class may define a
special method named `__init__()', like this:

    def __init__(self):
        self.data = []

When a class defines an `__init__()' method, class instantiation
automatically invokes `__init__()' for the newly-created class
instance.  So in this example, a new, initialized instance can be
obtained by:

    x = MyClass()

Of course, the `__init__()' method may have arguments for greater
flexibility.  In that case, arguments given to the class instantiation
operator are passed on to `__init__()'.  For example,

    >>> class Complex:
    ...     def __init__(self, realpart, imagpart):
    ...         self.r = realpart
    ...         self.i = imagpart
    ...
    >>> x = Complex(3.0, -4.5)
    >>> x.r, x.i
    (3.0, -4.5)



File: python-tutorial-3.2.2.info,  Node: Instance Objects,  Next: Method Objects,  Prev: Class Objects,  Up: A First Look at Classes

9.3.3 Instance Objects
----------------------

Now what can we do with instance objects?  The only operations
understood by instance objects are attribute references.  There are two
kinds of valid attribute names, data attributes and methods.

  _data attributes_ correspond to "instance variables" in Smalltalk,
and to "data members" in C++.  Data attributes need not be declared;
like local variables, they spring into existence when they are first
assigned to.  For example, if `x' is the instance of `MyClass' created
above, the following piece of code will print the value `16', without
leaving a trace:

    x.counter = 1
    while x.counter < 10:
        x.counter = x.counter * 2
    print(x.counter)
    del x.counter

The other kind of instance attribute reference is a _method_. A method
is a function that "belongs to" an object.  (In Python, the term method
is not unique to class instances: other object types can have methods
as well.  For example, list objects have methods called append, insert,
remove, sort, and so on.  However, in the following discussion, we'll
use the term method exclusively to mean methods of class instance
objects, unless explicitly stated otherwise.)

  Valid method names of an instance object depend on its class.  By
definition, all attributes of a class that are function  objects define
corresponding methods of its instances.  So in our example, `x.f' is a
valid method reference, since `MyClass.f' is a function, but `x.i' is
not, since `MyClass.i' is not.  But `x.f' is not the same thing as
`MyClass.f' -- it is a _method object_, not a function object.


File: python-tutorial-3.2.2.info,  Node: Method Objects,  Prev: Instance Objects,  Up: A First Look at Classes

9.3.4 Method Objects
--------------------

Usually, a method is called right after it is bound:

    x.f()

In the `MyClass' example, this will return the string `'hello world''.
However, it is not necessary to call a method right away: `x.f' is a
method object, and can be stored away and called at a later time.  For
example:

    xf = x.f
    while True:
        print(xf())

will continue to print `hello world' until the end of time.

  What exactly happens when a method is called?  You may have noticed
that `x.f()' was called without an argument above, even though the
function definition for `f()' specified an argument.  What happened to
the argument?  Surely Python raises an exception when a function that
requires an argument is called without any -- even if the argument
isn't actually used...

  Actually, you may have guessed the answer: the special thing about
methods is that the object is passed as the first argument of the
function.  In our example, the call `x.f()' is exactly equivalent to
`MyClass.f(x)'.  In general, calling a method with a list of _n_
arguments is equivalent to calling the corresponding function with an
argument list that is created by inserting the method's object before
the first argument.

  If you still don't understand how methods work, a look at the
implementation can perhaps clarify matters.  When an instance attribute
is referenced that isn't a data attribute, its class is searched.  If
the name denotes a valid class attribute that is a function object, a
method object is created by packing (pointers to) the instance object
and the function object just found together in an abstract object: this
is the method object.  When the method object is called with an
argument list, a new argument list is constructed from the instance
object and the argument list, and the function object is called with
this new argument list.


File: python-tutorial-3.2.2.info,  Node: Random Remarks,  Next: Inheritance,  Prev: A First Look at Classes,  Up: Classes

9.4 Random Remarks
==================

Data attributes override method attributes with the same name; to avoid
accidental name conflicts, which may cause hard-to-find bugs in large
programs, it is wise to use some kind of convention that minimizes the
chance of conflicts.  Possible conventions include capitalizing method
names, prefixing data attribute names with a small unique string
(perhaps just an underscore), or using verbs for methods and nouns for
data attributes.

  Data attributes may be referenced by methods as well as by ordinary
users ("clients") of an object.  In other words, classes are not usable
to implement pure abstract data types.  In fact, nothing in Python
makes it possible to enforce data hiding -- it is all based upon
convention.  (On the other hand, the Python implementation, written in
C, can completely hide implementation details and control access to an
object if necessary; this can be used by extensions to Python written
in C.)

  Clients should use data attributes with care -- clients may mess up
invariants maintained by the methods by stamping on their data
attributes.  Note that clients may add data attributes of their own to
an instance object without affecting the validity of the methods, as
long as name conflicts are avoided -- again, a naming convention can
save a lot of headaches here.

  There is no shorthand for referencing data attributes (or other
methods!) from within methods.  I find that this actually increases the
readability of methods: there is no chance of confusing local variables
and instance variables when glancing through a method.

  Often, the first argument of a method is called `self'.  This is
nothing more than a convention: the name `self' has absolutely no
special meaning to Python.  Note, however, that by not following the
convention your code may be less readable to other Python programmers,
and it is also conceivable that a _class browser_ program might be
written that relies upon such a convention.

  Any function object that is a class attribute defines a method for
instances of that class.  It is not necessary that the function
definition is textually enclosed in the class definition: assigning a
function object to a local variable in the class is also ok.  For
example:

    # Function defined outside the class
    def f1(self, x, y):
        return min(x, x+y)

    class C:
        f = f1
        def g(self):
            return 'hello world'
        h = g

Now `f', `g' and `h' are all attributes of class `C' that refer to
function objects, and consequently they are all methods of instances of
`C' -- `h' being exactly equivalent to `g'.  Note that this practice
usually only serves to confuse the reader of a program.

  Methods may call other methods by using method attributes of the
`self' argument:

    class Bag:
        def __init__(self):
            self.data = []
        def add(self, x):
            self.data.append(x)
        def addtwice(self, x):
            self.add(x)
            self.add(x)

Methods may reference global names in the same way as ordinary
functions.  The global scope associated with a method is the module
containing the class definition.  (The class itself is never used as a
global scope.)  While one rarely encounters a good reason for using
global data in a method, there are many legitimate uses of the global
scope: for one thing, functions and modules imported into the global
scope can be used by methods, as well as functions and classes defined
in it.  Usually, the class containing the method is itself defined in
this global scope, and in the next section we'll find some good reasons
why a method would want to reference its own class.

  Each value is an object, and therefore has a _class_ (also called its
_type_).  It is stored as `object.__class__'.


File: python-tutorial-3.2.2.info,  Node: Inheritance,  Next: Private Variables,  Prev: Random Remarks,  Up: Classes

9.5 Inheritance
===============

Of course, a language feature would not be worthy of the name "class"
without supporting inheritance.  The syntax for a derived class
definition looks like this:

    class DerivedClassName(BaseClassName):
        <statement-1>
        .
        .
        .
        <statement-N>

The name `BaseClassName' must be defined in a scope containing the
derived class definition.  In place of a base class name, other
arbitrary expressions are also allowed.  This can be useful, for
example, when the base class is defined in another module:

    class DerivedClassName(modname.BaseClassName):

Execution of a derived class definition proceeds the same as for a base
class.  When the class object is constructed, the base class is
remembered.  This is used for resolving attribute references: if a
requested attribute is not found in the class, the search proceeds to
look in the base class.  This rule is applied recursively if the base
class itself is derived from some other class.

  There's nothing special about instantiation of derived classes:
`DerivedClassName()' creates a new instance of the class.  Method
references are resolved as follows: the corresponding class attribute
is searched, descending down the chain of base classes if necessary,
and the method reference is valid if this yields a function object.

  Derived classes may override methods of their base classes.  Because
methods have no special privileges when calling other methods of the
same object, a method of a base class that calls another method defined
in the same base class may end up calling a method of a derived class
that overrides it.  (For C++ programmers: all methods in Python are
effectively `virtual'.)

  An overriding method in a derived class may in fact want to extend
rather than simply replace the base class method of the same name.
There is a simple way to call the base class method directly: just call
`BaseClassName.methodname(self, arguments)'.  This is occasionally
useful to clients as well.  (Note that this only works if the base
class is accessible as `BaseClassName' in the global scope.)

  Python has two built-in functions that work with inheritance:

   * Use `isinstance()' to check an instance's type: `isinstance(obj,
     int)' will be `True' only if `obj.__class__' is `int' or some class
     derived from `int'.

   * Use `issubclass()' to check class inheritance: `issubclass(bool,
     int)' is `True' since `bool' is a subclass of `int'.  However,
     `issubclass(float, int)' is `False' since `float' is not a
     subclass of `int'.

* Menu:

* Multiple Inheritance::


File: python-tutorial-3.2.2.info,  Node: Multiple Inheritance,  Up: Inheritance

9.5.1 Multiple Inheritance
--------------------------

Python supports a form of multiple inheritance as well.  A class
definition with multiple base classes looks like this:

    class DerivedClassName(Base1, Base2, Base3):
        <statement-1>
        .
        .
        .
        <statement-N>

For most purposes, in the simplest cases, you can think of the search
for attributes inherited from a parent class as depth-first,
left-to-right, not searching twice in the same class where there is an
overlap in the hierarchy.  Thus, if an attribute is not found in
`DerivedClassName', it is searched for in `Base1', then (recursively)
in the base classes of `Base1', and if it was not found there, it was
searched for in `Base2', and so on.

  In fact, it is slightly more complex than that; the method resolution
order changes dynamically to support cooperative calls to `super()'.
This approach is known in some other multiple-inheritance languages as
call-next-method and is more powerful than the super call found in
single-inheritance languages.

  Dynamic ordering is necessary because all cases of multiple
inheritance exhibit one or more diamond relationships (where at least
one of the parent classes can be accessed through multiple paths from
the bottommost class).  For example, all classes inherit from `object',
so any case of multiple inheritance provides more than one path to
reach `object'.  To keep the base classes from being accessed more than
once, the dynamic algorithm linearizes the search order in a way that
preserves the left-to-right ordering specified in each class, that
calls each parent only once, and that is monotonic (meaning that a
class can be subclassed without affecting the precedence order of its
parents).  Taken together, these properties make it possible to design
reliable and extensible classes with multiple inheritance.  For more
detail, see <http://www.python.org/download/releases/2.3/mro/>.


File: python-tutorial-3.2.2.info,  Node: Private Variables,  Next: Odds and Ends,  Prev: Inheritance,  Up: Classes

9.6 Private Variables
=====================

"Private" instance variables that cannot be accessed except from inside
an object don't exist in Python.  However, there is a convention that
is followed by most Python code: a name prefixed with an underscore
(e.g. `_spam') should be treated as a non-public part of the API
(whether it is a function, a method or a data member).  It should be
considered an implementation detail and subject to change without
notice.

  Since there is a valid use-case for class-private members (namely to
avoid name clashes of names with names defined by subclasses), there is
limited support for such a mechanism, called _name mangling_.  Any
identifier of the form `__spam' (at least two leading underscores, at
most one trailing underscore) is textually replaced with
`_classname__spam', where `classname' is the current class name with
leading underscore(s) stripped.  This mangling is done without regard
to the syntactic position of the identifier, as long as it occurs
within the definition of a class.

  Name mangling is helpful for letting subclasses override methods
without breaking intraclass method calls.  For example:

    class Mapping:
        def __init__(self, iterable):
            self.items_list = []
            self.__update(iterable)

        def update(self, iterable):
            for item in iterable:
                self.items_list.append(item)

        __update = update   # private copy of original update() method

    class MappingSubclass(Mapping):

        def update(self, keys, values):
            # provides new signature for update()
            # but does not break __init__()
            for item in zip(keys, values):
                self.items_list.append(item)

Note that the mangling rules are designed mostly to avoid accidents; it
still is possible to access or modify a variable that is considered
private.  This can even be useful in special circumstances, such as in
the debugger.

  Notice that code passed to `exec()' or `eval()' does not consider the
classname of the invoking class to be the current class; this is
similar to the effect of the `global' statement, the effect of which is
likewise restricted to code that is byte-compiled together.  The same
restriction applies to `getattr()', `setattr()' and `delattr()', as
well as when referencing `__dict__' directly.


File: python-tutorial-3.2.2.info,  Node: Odds and Ends,  Next: Exceptions Are Classes Too,  Prev: Private Variables,  Up: Classes

9.7 Odds and Ends
=================

Sometimes it is useful to have a data type similar to the Pascal
"record" or C "struct", bundling together a few named data items.  An
empty class definition will do nicely:

    class Employee:
        pass

    john = Employee() # Create an empty employee record

    # Fill the fields of the record
    john.name = 'John Doe'
    john.dept = 'computer lab'
    john.salary = 1000

A piece of Python code that expects a particular abstract data type can
often be passed a class that emulates the methods of that data type
instead.  For instance, if you have a function that formats some data
from a file object, you can define a class with methods `read()' and
`readline()' that get the data from a string buffer instead, and pass
it as an argument.

  Instance method objects have attributes, too: `m.__self__' is the
instance object with the method `m()', and `m.__func__' is the function
object corresponding to the method.


File: python-tutorial-3.2.2.info,  Node: Exceptions Are Classes Too,  Next: Iterators,  Prev: Odds and Ends,  Up: Classes

9.8 Exceptions Are Classes Too
==============================

User-defined exceptions are identified by classes as well.  Using this
mechanism it is possible to create extensible hierarchies of exceptions.

  There are two new valid (semantic) forms for the `raise' statement:

    raise Class

    raise Instance

In the first form, `Class' must be an instance of `type' or of a class
derived from it.  The first form is a shorthand for:

    raise Class()

A class in an `except' clause is compatible with an exception if it is
the same class or a base class thereof (but not the other way around --
an except clause listing a derived class is not compatible with a base
class).  For example, the following code will print B, C, D in that
order:

    class B(Exception):
        pass
    class C(B):
        pass
    class D(C):
        pass

    for c in [B, C, D]:
        try:
            raise c()
        except D:
            print("D")
        except C:
            print("C")
        except B:
            print("B")

Note that if the except clauses were reversed (with `except B' first),
it would have printed B, B, B -- the first matching except clause is
triggered.

  When an error message is printed for an unhandled exception, the
exception's class name is printed, then a colon and a space, and
finally the instance converted to a string using the built-in function
`str()'.


File: python-tutorial-3.2.2.info,  Node: Iterators,  Next: Generators,  Prev: Exceptions Are Classes Too,  Up: Classes

9.9 Iterators
=============

By now you have probably noticed that most container objects can be
looped over using a `for' statement:

    for element in [1, 2, 3]:
        print(element)
    for element in (1, 2, 3):
        print(element)
    for key in {'one':1, 'two':2}:
        print(key)
    for char in "123":
        print(char)
    for line in open("myfile.txt"):
        print(line)

This style of access is clear, concise, and convenient.  The use of
iterators pervades and unifies Python.  Behind the scenes, the `for'
statement calls `iter()' on the container object.  The function returns
an iterator object that defines the method `__next__()' which accesses
elements in the container one at a time.  When there are no more
elements, `__next__()' raises a `StopIteration' exception which tells
the `for' loop to terminate.  You can call the `__next__()' method
using the `next()' built-in function; this example shows how it all
works:

    >>> s = 'abc'
    >>> it = iter(s)
    >>> it
    <iterator object at 0x00A1DB50>
    >>> next(it)
    'a'
    >>> next(it)
    'b'
    >>> next(it)
    'c'
    >>> next(it)
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
        next(it)
    StopIteration

Having seen the mechanics behind the iterator protocol, it is easy to
add iterator behavior to your classes.  Define an `__iter__()' method
which returns an object with a `__next__()' method.  If the class
defines `__next__()', then `__iter__()' can just return `self':

    class Reverse:
        """Iterator for looping over a sequence backwards."""
        def __init__(self, data):
            self.data = data
            self.index = len(data)
        def __iter__(self):
            return self
        def __next__(self):
            if self.index == 0:
                raise StopIteration
            self.index = self.index - 1
            return self.data[self.index]


    >>> rev = Reverse('spam')
    >>> iter(rev)
    <__main__.Reverse object at 0x00A1DB50>
    >>> for char in rev:
    ...     print(char)
    ...
    m
    a
    p
    s



File: python-tutorial-3.2.2.info,  Node: Generators,  Next: Generator Expressions,  Prev: Iterators,  Up: Classes

9.10 Generators
===============

_Generator_s are a simple and powerful tool for creating iterators.
They are written like regular functions but use the `yield' statement
whenever they want to return data.  Each time `next()' is called on it,
the generator resumes where it left-off (it remembers all the data
values and which statement was last executed).  An example shows that
generators can be trivially easy to create:

    def reverse(data):
        for index in range(len(data)-1, -1, -1):
            yield data[index]


    >>> for char in reverse('golf'):
    ...     print(char)
    ...
    f
    l
    o
    g

Anything that can be done with generators can also be done with class
based iterators as described in the previous section.  What makes
generators so compact is that the `__iter__()' and `__next__()' methods
are created automatically.

  Another key feature is that the local variables and execution state
are automatically saved between calls.  This made the function easier
to write and much more clear than an approach using instance variables
like `self.index' and `self.data'.

  In addition to automatic method creation and saving program state,
when generators terminate, they automatically raise `StopIteration'. In
combination, these features make it easy to create iterators with no
more effort than writing a regular function.


File: python-tutorial-3.2.2.info,  Node: Generator Expressions,  Prev: Generators,  Up: Classes

9.11 Generator Expressions
==========================

Some simple generators can be coded succinctly as expressions using a
syntax similar to list comprehensions but with parentheses instead of
brackets.  These expressions are designed for situations where the
generator is used right away by an enclosing function.  Generator
expressions are more compact but less versatile than full generator
definitions and tend to be more memory friendly than equivalent list
comprehensions.

  Examples:

    >>> sum(i*i for i in range(10))                 # sum of squares
    285

    >>> xvec = [10, 20, 30]
    >>> yvec = [7, 5, 3]
    >>> sum(x*y for x,y in zip(xvec, yvec))         # dot product
    260

    >>> from math import pi, sin
    >>> sine_table = {x: sin(x*pi/180) for x in range(0, 91)}

    >>> unique_words = set(word  for line in page  for word in line.split())

    >>> valedictorian = max((student.gpa, student.name) for student in graduates)

    >>> data = 'golf'
    >>> list(data[i] for i in range(len(data)-1, -1, -1))
    ['f', 'l', 'o', 'g']



File: python-tutorial-3.2.2.info,  Node: Brief Tour of the Standard Library,  Next: Brief Tour of the Standard Library -- Part II,  Prev: Classes,  Up: Top

10 Brief Tour of the Standard Library
*************************************

* Menu:

* Operating System Interface::
* File Wildcards::
* Command Line Arguments::
* Error Output Redirection and Program Termination::
* String Pattern Matching::
* Mathematics::
* Internet Access::
* Dates and Times::
* Data Compression::
* Performance Measurement::
* Quality Control::
* Batteries Included::


File: python-tutorial-3.2.2.info,  Node: Operating System Interface,  Next: File Wildcards,  Up: Brief Tour of the Standard Library

10.1 Operating System Interface
===============================

The `os' module provides dozens of functions for interacting with the
operating system:

    >>> import os
    >>> os.getcwd()      # Return the current working directory
    'C:\\Python31'
    >>> os.chdir('/server/accesslogs')   # Change current working directory
    >>> os.system('mkdir today')   # Run the command mkdir in the system shell
    0

Be sure to use the `import os' style instead of `from os import *'.
This will keep `os.open()' from shadowing the built-in `open()'
function which operates much differently.

  The built-in `dir()' and `help()' functions are useful as interactive
aids for working with large modules like `os':

    >>> import os
    >>> dir(os)
    <returns a list of all module functions>
    >>> help(os)
    <returns an extensive manual page created from the module's docstrings>

For daily file and directory management tasks, the `shutil' module
provides a higher level interface that is easier to use:

    >>> import shutil
    >>> shutil.copyfile('data.db', 'archive.db')
    >>> shutil.move('/build/executables', 'installdir')



File: python-tutorial-3.2.2.info,  Node: File Wildcards,  Next: Command Line Arguments,  Prev: Operating System Interface,  Up: Brief Tour of the Standard Library

10.2 File Wildcards
===================

The `glob' module provides a function for making file lists from
directory wildcard searches:

    >>> import glob
    >>> glob.glob('*.py')
    ['primes.py', 'random.py', 'quote.py']



File: python-tutorial-3.2.2.info,  Node: Command Line Arguments,  Next: Error Output Redirection and Program Termination,  Prev: File Wildcards,  Up: Brief Tour of the Standard Library

10.3 Command Line Arguments
===========================

Common utility scripts often need to process command line arguments.
These arguments are stored in the `sys' module's _argv_ attribute as a
list.  For instance the following output results from running `python
demo.py one two three' at the command line:

    >>> import sys
    >>> print(sys.argv)
    ['demo.py', 'one', 'two', 'three']

The `getopt' module processes _sys.argv_ using the conventions of the
Unix `getopt()' function.  More powerful and flexible command line
processing is provided by the `argparse' module.


File: python-tutorial-3.2.2.info,  Node: Error Output Redirection and Program Termination,  Next: String Pattern Matching,  Prev: Command Line Arguments,  Up: Brief Tour of the Standard Library

10.4 Error Output Redirection and Program Termination
=====================================================

The `sys' module also has attributes for _stdin_, _stdout_, and
_stderr_.  The latter is useful for emitting warnings and error
messages to make them visible even when _stdout_ has been redirected:

    >>> sys.stderr.write('Warning, log file not found starting a new one\n')
    Warning, log file not found starting a new one

The most direct way to terminate a script is to use `sys.exit()'.


File: python-tutorial-3.2.2.info,  Node: String Pattern Matching,  Next: Mathematics,  Prev: Error Output Redirection and Program Termination,  Up: Brief Tour of the Standard Library

10.5 String Pattern Matching
============================

The `re' module provides regular expression tools for advanced string
processing. For complex matching and manipulation, regular expressions
offer succinct, optimized solutions:

    >>> import re
    >>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
    ['foot', 'fell', 'fastest']
    >>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
    'cat in the hat'

When only simple capabilities are needed, string methods are preferred
because they are easier to read and debug:

    >>> 'tea for too'.replace('too', 'two')
    'tea for two'



File: python-tutorial-3.2.2.info,  Node: Mathematics,  Next: Internet Access,  Prev: String Pattern Matching,  Up: Brief Tour of the Standard Library

10.6 Mathematics
================

The `math' module gives access to the underlying C library functions for
floating point math:

    >>> import math
    >>> math.cos(math.pi / 4)
    0.70710678118654757
    >>> math.log(1024, 2)
    10.0

The `random' module provides tools for making random selections:

    >>> import random
    >>> random.choice(['apple', 'pear', 'banana'])
    'apple'
    >>> random.sample(range(100), 10)   # sampling without replacement
    [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
    >>> random.random()    # random float
    0.17970987693706186
    >>> random.randrange(6)    # random integer chosen from range(6)
    4

The SciPy project <<http://scipy.org>> has many other modules for
numerical computations.


File: python-tutorial-3.2.2.info,  Node: Internet Access,  Next: Dates and Times,  Prev: Mathematics,  Up: Brief Tour of the Standard Library

10.7 Internet Access
====================

There are a number of modules for accessing the internet and processing
internet protocols. Two of the simplest are `urllib.request' for
retrieving data from urls and `smtplib' for sending mail:

    >>> from urllib.request import urlopen
    >>> for line in urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'):
    ...     line = line.decode('utf-8')  # Decoding the binary data to text.
    ...     if 'EST' in line or 'EDT' in line:  # look for Eastern Time
    ...         print(line)

    <BR>Nov. 25, 09:43:32 PM EST

    >>> import smtplib
    >>> server = smtplib.SMTP('localhost')
    >>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
    ... """To: jcaesar@example.org
    ... From: soothsayer@example.org
    ...
    ... Beware the Ides of March.
    ... """)
    >>> server.quit()

(Note that the second example needs a mailserver running on localhost.)


File: python-tutorial-3.2.2.info,  Node: Dates and Times,  Next: Data Compression,  Prev: Internet Access,  Up: Brief Tour of the Standard Library

10.8 Dates and Times
====================

The `datetime' module supplies classes for manipulating dates and times
in both simple and complex ways. While date and time arithmetic is
supported, the focus of the implementation is on efficient member
extraction for output formatting and manipulation.  The module also
supports objects that are timezone aware.

    >>> # dates are easily constructed and formatted
    >>> from datetime import date
    >>> now = date.today()
    >>> now
    datetime.date(2003, 12, 2)
    >>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
    '12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'

    >>> # dates support calendar arithmetic
    >>> birthday = date(1964, 7, 31)
    >>> age = now - birthday
    >>> age.days
    14368



File: python-tutorial-3.2.2.info,  Node: Data Compression,  Next: Performance Measurement,  Prev: Dates and Times,  Up: Brief Tour of the Standard Library

10.9 Data Compression
=====================

Common data archiving and compression formats are directly supported by
modules including: `zlib', `gzip', `bz2', `zipfile' and `tarfile'.

    >>> import zlib
    >>> s = b'witch which has which witches wrist watch'
    >>> len(s)
    41
    >>> t = zlib.compress(s)
    >>> len(t)
    37
    >>> zlib.decompress(t)
    b'witch which has which witches wrist watch'
    >>> zlib.crc32(s)
    226805979



File: python-tutorial-3.2.2.info,  Node: Performance Measurement,  Next: Quality Control,  Prev: Data Compression,  Up: Brief Tour of the Standard Library

10.10 Performance Measurement
=============================

Some Python users develop a deep interest in knowing the relative
performance of different approaches to the same problem. Python
provides a measurement tool that answers those questions immediately.

  For example, it may be tempting to use the tuple packing and
unpacking feature instead of the traditional approach to swapping
arguments. The `timeit' module quickly demonstrates a modest
performance advantage:

    >>> from timeit import Timer
    >>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
    0.57535828626024577
    >>> Timer('a,b = b,a', 'a=1; b=2').timeit()
    0.54962537085770791

In contrast to `timeit''s fine level of granularity, the `profile' and
`pstats' modules provide tools for identifying time critical sections in
larger blocks of code.


File: python-tutorial-3.2.2.info,  Node: Quality Control,  Next: Batteries Included,  Prev: Performance Measurement,  Up: Brief Tour of the Standard Library

10.11 Quality Control
=====================

One approach for developing high quality software is to write tests for
each function as it is developed and to run those tests frequently
during the development process.

  The `doctest' module provides a tool for scanning a module and
validating tests embedded in a program's docstrings.  Test construction
is as simple as cutting-and-pasting a typical call along with its
results into the docstring.  This improves the documentation by
providing the user with an example and it allows the doctest module to
make sure the code remains true to the documentation:

    def average(values):
        """Computes the arithmetic mean of a list of numbers.

        >>> print(average([20, 30, 70]))
        40.0
        """
        return sum(values) / len(values)

    import doctest
    doctest.testmod()   # automatically validate the embedded tests

The `unittest' module is not as effortless as the `doctest' module, but
it allows a more comprehensive set of tests to be maintained in a
separate file:

    import unittest

    class TestStatisticalFunctions(unittest.TestCase):

        def test_average(self):
            self.assertEqual(average([20, 30, 70]), 40.0)
            self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
            self.assertRaises(ZeroDivisionError, average, [])
            self.assertRaises(TypeError, average, 20, 30, 70)

    unittest.main() # Calling from the command line invokes all tests



File: python-tutorial-3.2.2.info,  Node: Batteries Included,  Prev: Quality Control,  Up: Brief Tour of the Standard Library

10.12 Batteries Included
========================

Python has a "batteries included" philosophy.  This is best seen
through the sophisticated and robust capabilities of its larger
packages. For example:

   * The `xmlrpc.client' and `xmlrpc.server' modules make implementing
     remote procedure calls into an almost trivial task.  Despite the
     modules names, no direct knowledge or handling of XML is needed.

   * The `email' package is a library for managing email messages,
     including MIME and other RFC 2822-based message documents. Unlike
     `smtplib' and `poplib' which actually send and receive messages,
     the email package has a complete toolset for building or decoding
     complex message structures (including attachments) and for
     implementing internet encoding and header protocols.

   * The `xml.dom' and `xml.sax' packages provide robust support for
     parsing this popular data interchange format. Likewise, the `csv'
     module supports direct reads and writes in a common database
     format. Together, these modules and packages greatly simplify data
     interchange between Python applications and other tools.

   * Internationalization is supported by a number of modules including
     `gettext', `locale', and the `codecs' package.


File: python-tutorial-3.2.2.info,  Node: Brief Tour of the Standard Library -- Part II,  Next: What Now?,  Prev: Brief Tour of the Standard Library,  Up: Top

11 Brief Tour of the Standard Library - Part II
***********************************************

This second tour covers more advanced modules that support professional
programming needs.  These modules rarely occur in small scripts.

* Menu:

* Output Formatting::
* Templating::
* Working with Binary Data Record Layouts::
* Multi-threading::
* Logging::
* Weak References::
* Tools for Working with Lists::
* Decimal Floating Point Arithmetic::


File: python-tutorial-3.2.2.info,  Node: Output Formatting,  Next: Templating,  Up: Brief Tour of the Standard Library -- Part II

11.1 Output Formatting
======================

The `reprlib' module provides a version of `repr()' customized for
abbreviated displays of large or deeply nested containers:

    >>> import reprlib
    >>> reprlib.repr(set('supercalifragilisticexpialidocious'))
    "set(['a', 'c', 'd', 'e', 'f', 'g', ...])"

The `pprint' module offers more sophisticated control over printing both
built-in and user defined objects in a way that is readable by the
interpreter.  When the result is longer than one line, the "pretty
printer" adds line breaks and indentation to more clearly reveal data
structure:

    >>> import pprint
    >>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
    ...     'yellow'], 'blue']]]
    ...
    >>> pprint.pprint(t, width=30)
    [[[['black', 'cyan'],
       'white',
       ['green', 'red']],
      [['magenta', 'yellow'],
       'blue']]]

The `textwrap' module formats paragraphs of text to fit a given screen
width:

    >>> import textwrap
    >>> doc = """The wrap() method is just like fill() except that it returns
    ... a list of strings instead of one big string with newlines to separate
    ... the wrapped lines."""
    ...
    >>> print(textwrap.fill(doc, width=40))
    The wrap() method is just like fill()
    except that it returns a list of strings
    instead of one big string with newlines
    to separate the wrapped lines.

The `locale' module accesses a database of culture specific data
formats.  The grouping attribute of locale's format function provides a
direct way of formatting numbers with group separators:

    >>> import locale
    >>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
    'English_United States.1252'
    >>> conv = locale.localeconv()          # get a mapping of conventions
    >>> x = 1234567.8
    >>> locale.format("%d", x, grouping=True)
    '1,234,567'
    >>> locale.format_string("%s%.*f", (conv['currency_symbol'],
    ...                      conv['frac_digits'], x), grouping=True)
    '$1,234,567.80'



File: python-tutorial-3.2.2.info,  Node: Templating,  Next: Working with Binary Data Record Layouts,  Prev: Output Formatting,  Up: Brief Tour of the Standard Library -- Part II

11.2 Templating
===============

The `string' module includes a versatile `Template' class with a
simplified syntax suitable for editing by end-users.  This allows users
to customize their applications without having to alter the application.

  The format uses placeholder names formed by `$' with valid Python
identifiers (alphanumeric characters and underscores).  Surrounding the
placeholder with braces allows it to be followed by more alphanumeric
letters with no intervening spaces.  Writing `$$' creates a single
escaped `$':

    >>> from string import Template
    >>> t = Template('${village}folk send $$10 to $cause.')
    >>> t.substitute(village='Nottingham', cause='the ditch fund')
    'Nottinghamfolk send $10 to the ditch fund.'

The `substitute()' method raises a `KeyError' when a placeholder is not
supplied in a dictionary or a keyword argument. For mail-merge style
applications, user supplied data may be incomplete and the
`safe_substitute()' method may be more appropriate -- it will leave
placeholders unchanged if data is missing:

    >>> t = Template('Return the $item to $owner.')
    >>> d = dict(item='unladen swallow')
    >>> t.substitute(d)
    Traceback (most recent call last):
      . . .
    KeyError: 'owner'
    >>> t.safe_substitute(d)
    'Return the unladen swallow to $owner.'

Template subclasses can specify a custom delimiter.  For example, a
batch renaming utility for a photo browser may elect to use percent
signs for placeholders such as the current date, image sequence number,
or file format:

    >>> import time, os.path
    >>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
    >>> class BatchRename(Template):
    ...     delimiter = '%'
    >>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')
    Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f

    >>> t = BatchRename(fmt)
    >>> date = time.strftime('%d%b%y')
    >>> for i, filename in enumerate(photofiles):
    ...     base, ext = os.path.splitext(filename)
    ...     newname = t.substitute(d=date, n=i, f=ext)
    ...     print('{0} --> {1}'.format(filename, newname))

    img_1074.jpg --> Ashley_0.jpg
    img_1076.jpg --> Ashley_1.jpg
    img_1077.jpg --> Ashley_2.jpg

Another application for templating is separating program logic from the
details of multiple output formats.  This makes it possible to
substitute custom templates for XML files, plain text reports, and HTML
web reports.


File: python-tutorial-3.2.2.info,  Node: Working with Binary Data Record Layouts,  Next: Multi-threading,  Prev: Templating,  Up: Brief Tour of the Standard Library -- Part II

11.3 Working with Binary Data Record Layouts
============================================

The `struct' module provides `pack()' and `unpack()' functions for
working with variable length binary record formats.  The following
example shows how to loop through header information in a ZIP file
without using the `zipfile' module.  Pack codes `"H"' and `"I"'
represent two and four byte unsigned numbers respectively.  The `"<"'
indicates that they are standard size and in little-endian byte order:

    import struct

    data = open('myfile.zip', 'rb').read()
    start = 0
    for i in range(3):                      # show the first 3 file headers
        start += 14
        fields = struct.unpack('<IIIHH', data[start:start+16])
        crc32, comp_size, uncomp_size, filenamesize, extra_size = fields

        start += 16
        filename = data[start:start+filenamesize]
        start += filenamesize
        extra = data[start:start+extra_size]
        print(filename, hex(crc32), comp_size, uncomp_size)

        start += extra_size + comp_size     # skip to the next header



File: python-tutorial-3.2.2.info,  Node: Multi-threading,  Next: Logging,  Prev: Working with Binary Data Record Layouts,  Up: Brief Tour of the Standard Library -- Part II

11.4 Multi-threading
====================

Threading is a technique for decoupling tasks which are not sequentially
dependent.  Threads can be used to improve the responsiveness of
applications that accept user input while other tasks run in the
background.  A related use case is running I/O in parallel with
computations in another thread.

  The following code shows how the high level `threading' module can run
tasks in background while the main program continues to run:

    import threading, zipfile

    class AsyncZip(threading.Thread):
        def __init__(self, infile, outfile):
            threading.Thread.__init__(self)
            self.infile = infile
            self.outfile = outfile
        def run(self):
            f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
            f.write(self.infile)
            f.close()
            print('Finished background zip of:', self.infile)

    background = AsyncZip('mydata.txt', 'myarchive.zip')
    background.start()
    print('The main program continues to run in foreground.')

    background.join()    # Wait for the background task to finish
    print('Main program waited until background was done.')

The principal challenge of multi-threaded applications is coordinating
threads that share data or other resources.  To that end, the threading
module provides a number of synchronization primitives including locks,
events, condition variables, and semaphores.

  While those tools are powerful, minor design errors can result in
problems that are difficult to reproduce.  So, the preferred approach
to task coordination is to concentrate all access to a resource in a
single thread and then use the `queue' module to feed that thread with
requests from other threads.  Applications using `Queue' objects for
inter-thread communication and coordination are easier to design, more
readable, and more reliable.


File: python-tutorial-3.2.2.info,  Node: Logging,  Next: Weak References,  Prev: Multi-threading,  Up: Brief Tour of the Standard Library -- Part II

11.5 Logging
============

The `logging' module offers a full featured and flexible logging system.
At its simplest, log messages are sent to a file or to `sys.stderr':

    import logging
    logging.debug('Debugging information')
    logging.info('Informational message')
    logging.warning('Warning:config file %s not found', 'server.conf')
    logging.error('Error occurred')
    logging.critical('Critical error -- shutting down')

This produces the following output:

    WARNING:root:Warning:config file server.conf not found
    ERROR:root:Error occurred
    CRITICAL:root:Critical error -- shutting down

By default, informational and debugging messages are suppressed and the
output is sent to standard error.  Other output options include routing
messages through email, datagrams, sockets, or to an HTTP Server.  New
filters can select different routing based on message priority:
`DEBUG', `INFO', `WARNING', `ERROR', and `CRITICAL'.

  The logging system can be configured directly from Python or can be
loaded from a user editable configuration file for customized logging
without altering the application.


File: python-tutorial-3.2.2.info,  Node: Weak References,  Next: Tools for Working with Lists,  Prev: Logging,  Up: Brief Tour of the Standard Library -- Part II

11.6 Weak References
====================

Python does automatic memory management (reference counting for most
objects and _garbage collection_ to eliminate cycles).  The memory is
freed shortly after the last reference to it has been eliminated.

  This approach works fine for most applications but occasionally there
is a need to track objects only as long as they are being used by
something else.  Unfortunately, just tracking them creates a reference
that makes them permanent.  The `weakref' module provides tools for
tracking objects without creating a reference.  When the object is no
longer needed, it is automatically removed from a weakref table and a
callback is triggered for weakref objects.  Typical applications
include caching objects that are expensive to create:

    >>> import weakref, gc
    >>> class A:
    ...     def __init__(self, value):
    ...             self.value = value
    ...     def __repr__(self):
    ...             return str(self.value)
    ...
    >>> a = A(10)                   # create a reference
    >>> d = weakref.WeakValueDictionary()
    >>> d['primary'] = a            # does not create a reference
    >>> d['primary']                # fetch the object if it is still alive
    10
    >>> del a                       # remove the one reference
    >>> gc.collect()                # run garbage collection right away
    0
    >>> d['primary']                # entry was automatically removed
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
        d['primary']                # entry was automatically removed
      File "C:/python31/lib/weakref.py", line 46, in __getitem__
        o = self.data[key]()
    KeyError: 'primary'



File: python-tutorial-3.2.2.info,  Node: Tools for Working with Lists,  Next: Decimal Floating Point Arithmetic,  Prev: Weak References,  Up: Brief Tour of the Standard Library -- Part II

11.7 Tools for Working with Lists
=================================

Many data structure needs can be met with the built-in list type.
However, sometimes there is a need for alternative implementations with
different performance trade-offs.

  The `array' module provides an `array()' object that is like a list
that stores only homogeneous data and stores it more compactly.  The
following example shows an array of numbers stored as two byte unsigned
binary numbers (typecode `"H"') rather than the usual 16 bytes per
entry for regular lists of Python int objects:

    >>> from array import array
    >>> a = array('H', [4000, 10, 700, 22222])
    >>> sum(a)
    26932
    >>> a[1:3]
    array('H', [10, 700])

The `collections' module provides a `deque()' object that is like a
list with faster appends and pops from the left side but slower lookups
in the middle. These objects are well suited for implementing queues
and breadth first tree searches:

    >>> from collections import deque
    >>> d = deque(["task1", "task2", "task3"])
    >>> d.append("task4")
    >>> print("Handling", d.popleft())
    Handling task1

    unsearched = deque([starting_node])
    def breadth_first_search(unsearched):
        node = unsearched.popleft()
        for m in gen_moves(node):
            if is_goal(m):
                return m
            unsearched.append(m)

In addition to alternative list implementations, the library also
offers other tools such as the `bisect' module with functions for
manipulating sorted lists:

    >>> import bisect
    >>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
    >>> bisect.insort(scores, (300, 'ruby'))
    >>> scores
    [(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]

The `heapq' module provides functions for implementing heaps based on
regular lists.  The lowest valued entry is always kept at position
zero.  This is useful for applications which repeatedly access the
smallest element but do not want to run a full list sort:

    >>> from heapq import heapify, heappop, heappush
    >>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
    >>> heapify(data)                      # rearrange the list into heap order
    >>> heappush(data, -5)                 # add a new entry
    >>> [heappop(data) for i in range(3)]  # fetch the three smallest entries
    [-5, 0, 1]



File: python-tutorial-3.2.2.info,  Node: Decimal Floating Point Arithmetic,  Prev: Tools for Working with Lists,  Up: Brief Tour of the Standard Library -- Part II

11.8 Decimal Floating Point Arithmetic
======================================

The `decimal' module offers a `Decimal' datatype for decimal floating
point arithmetic.  Compared to the built-in `float' implementation of
binary floating point, the class is especially helpful for

   * financial applications and other uses which require exact decimal
     representation,

   * control over precision,

   * control over rounding to meet legal or regulatory requirements,

   * tracking of significant decimal places, or

   * applications where the user expects the results to match
     calculations done by hand.

  For example, calculating a 5% tax on a 70 cent phone charge gives
different results in decimal floating point and binary floating point.
The difference becomes significant if the results are rounded to the
nearest cent:

    >>> from decimal import *
    >>> round(Decimal('0.70') * Decimal('1.05'), 2)
    Decimal('0.74')
    >>> round(.70 * 1.05, 2)
    0.73

The `Decimal' result keeps a trailing zero, automatically inferring four
place significance from multiplicands with two place significance.
Decimal reproduces mathematics as done by hand and avoids issues that
can arise when binary floating point cannot exactly represent decimal
quantities.

  Exact representation enables the `Decimal' class to perform modulo
calculations and equality tests that are unsuitable for binary floating
point:

    >>> Decimal('1.00') % Decimal('.10')
    Decimal('0.00')
    >>> 1.00 % 0.10
    0.09999999999999995

    >>> sum([Decimal('0.1')]*10) == Decimal('1.0')
    True
    >>> sum([0.1]*10) == 1.0
    False

The `decimal' module provides arithmetic with as much precision as
needed:

    >>> getcontext().prec = 36
    >>> Decimal(1) / Decimal(7)
    Decimal('0.142857142857142857142857142857142857')



File: python-tutorial-3.2.2.info,  Node: What Now?,  Next: Interactive Input Editing and History Substitution,  Prev: Brief Tour of the Standard Library -- Part II,  Up: Top

12 What Now?
************

Reading this tutorial has probably reinforced your interest in using
Python -- you should be eager to apply Python to solving your
real-world problems. Where should you go to learn more?

  This tutorial is part of Python's documentation set.   Some other
documents in the set are:

   * _library-index_:

     You should browse through this manual, which gives complete
     (though terse) reference material about types, functions, and the
     modules in the standard library.  The standard Python distribution
     includes a _lot_ of additional code.  There are modules to read
     Unix mailboxes, retrieve documents via HTTP, generate random
     numbers, parse command-line options, write CGI programs, compress
     data, and many other tasks. Skimming through the Library Reference
     will give you an idea of what's available.

   * _install-index_ explains how to install external modules written
     by other Python users.

   * _reference-index_: A detailed explanation of Python's syntax and
     semantics.  It's heavy reading, but is useful as a complete guide
     to the language itself.

  More Python resources:

   * <http://www.python.org>:  The major Python Web site.  It contains
     code, documentation, and pointers to Python-related pages around
     the Web.  This Web site is mirrored in various places around the
     world, such as Europe, Japan, and Australia; a mirror may be
     faster than the main site, depending on your geographical location.

   * <http://docs.python.org>:  Fast access to Python's  documentation.

   * <http://pypi.python.org>: The Python Package Index, previously
     also nicknamed the Cheese Shop, is an index of user-created Python
     modules that are available for download.  Once you begin releasing
     code, you can register it here so that others can find it.

   * <http://aspn.activestate.com/ASPN/Python/Cookbook/>: The Python
     Cookbook is a sizable collection of code examples, larger modules,
     and useful scripts.  Particularly notable contributions are
     collected in a book also titled Python Cookbook (O'Reilly &
     Associates, ISBN 0-596-00797-3.)

   * <http://scipy.org>: The Scientific Python project includes modules
     for fast array computations and manipulations plus a host of
     packages for such things as linear algebra, Fourier transforms,
     non-linear solvers, random number distributions, statistical
     analysis and the like.

  For Python-related questions and problem reports, you can post to the
newsgroup `comp.lang.python', or send them to the mailing list at
<python-list@python.org>.  The newsgroup and mailing list are
gatewayed, so messages posted to one will automatically be forwarded to
the other.  There are around 120 postings a day (with peaks up to
several hundred), asking (and answering) questions, suggesting new
features, and announcing new modules.  Before posting, be sure to check
the list of Frequently Asked Questions(1) (also called the FAQ), or
look for it in the `Misc/' directory of the Python source distribution.
Mailing list archives are available at
<http://mail.python.org/pipermail/>. The FAQ answers many of the
questions that come up again and again, and may already contain the
solution for your problem.

  ---------- Footnotes ----------

  (1) http://www.python.org/doc/faq/


File: python-tutorial-3.2.2.info,  Node: Interactive Input Editing and History Substitution,  Next: Floating Point Arithmetic Issues and Limitations,  Prev: What Now?,  Up: Top

13 Interactive Input Editing and History Substitution
*****************************************************

Some versions of the Python interpreter support editing of the current
input line and history substitution, similar to facilities found in the
Korn shell and the GNU Bash shell.  This is implemented using the GNU
Readline(1) library, which supports Emacs-style and vi-style editing.
This library has its own documentation which I won't duplicate here;
however, the basics are easily explained.  The interactive editing and
history described here are optionally available in the Unix and Cygwin
versions of the interpreter.

  This chapter does _not_ document the editing facilities of Mark
Hammond's PythonWin package or the Tk-based environment, IDLE,
distributed with Python.  The command line history recall which
operates within DOS boxes on NT and some other DOS and Windows flavors
is yet another beast.

* Menu:

* Line Editing::
* History Substitution::
* Key Bindings::
* Alternatives to the Interactive Interpreter::

  ---------- Footnotes ----------

  (1) http://tiswww.case.edu/php/chet/readline/rltop.html


File: python-tutorial-3.2.2.info,  Node: Line Editing,  Next: History Substitution,  Up: Interactive Input Editing and History Substitution

13.1 Line Editing
=================

If supported, input line editing is active whenever the interpreter
prints a primary or secondary prompt.  The current line can be edited
using the conventional Emacs control characters.  The most important of
these are: `C-A' (Control-A) moves the cursor to the beginning of the
line, `C-E' to the end, `C-B' moves it one position to the left, `C-F'
to the right.  Backspace erases the character to the left of the
cursor, `C-D' the character to its right. `C-K' kills (erases) the rest
of the line to the right of the cursor, `C-Y' yanks back the last
killed string.  `C-underscore' undoes the last change you made; it can
be repeated for cumulative effect.


File: python-tutorial-3.2.2.info,  Node: History Substitution,  Next: Key Bindings,  Prev: Line Editing,  Up: Interactive Input Editing and History Substitution

13.2 History Substitution
=========================

History substitution works as follows.  All non-empty input lines
issued are saved in a history buffer, and when a new prompt is given
you are positioned on a new line at the bottom of this buffer. `C-P'
moves one line up (back) in the history buffer, `C-N' moves one down.
Any line in the history buffer can be edited; an asterisk appears in
front of the prompt to mark a line as modified.  Pressing the `Return'
key passes the current line to the interpreter.  `C-R' starts an
incremental reverse search; `C-S' starts a forward search.


File: python-tutorial-3.2.2.info,  Node: Key Bindings,  Next: Alternatives to the Interactive Interpreter,  Prev: History Substitution,  Up: Interactive Input Editing and History Substitution

13.3 Key Bindings
=================

The key bindings and some other parameters of the Readline library can
be customized by placing commands in an initialization file called
`~/.inputrc'.  Key bindings have the form

    key-name: function-name

or

    "string": function-name

and options can be set with

    set option-name value

For example:

    # I prefer vi-style editing:
    set editing-mode vi

    # Edit using a single line:
    set horizontal-scroll-mode On

    # Rebind some keys:
    Meta-h: backward-kill-word
    "\C-u": universal-argument
    "\C-x\C-r": re-read-init-file

Note that the default binding for `Tab' in Python is to insert a `Tab'
character instead of Readline's default filename completion function.
If you insist, you can override this by putting

    Tab: complete

in your `~/.inputrc'.  (Of course, this makes it harder to type indented
continuation lines if you're accustomed to using `Tab' for that
purpose.)

  Automatic completion of variable and module names is optionally
available.  To enable it in the interpreter's interactive mode, add the
following to your startup file: (1)

    import rlcompleter, readline
    readline.parse_and_bind('tab: complete')

This binds the `Tab' key to the completion function, so hitting the
`Tab' key twice suggests completions; it looks at Python statement
names, the current local variables, and the available module names.
For dotted expressions such as `string.a', it will evaluate the
expression up to the final `'.'' and then suggest completions from the
attributes of the resulting object.  Note that this may execute
application-defined code if an object with a `__getattr__()' method is
part of the expression.

  A more capable startup file might look like this example.  Note that
this deletes the names it creates once they are no longer needed; this
is done since the startup file is executed in the same namespace as the
interactive commands, and removing the names avoids creating side
effects in the interactive environment.  You may find it convenient to
keep some of the imported modules, such as `os', which turn out to be
needed in most sessions with the interpreter.

    # Add auto-completion and a stored history file of commands to your Python
    # interactive interpreter. Requires Python 2.0+, readline. Autocomplete is
    # bound to the Esc key by default (you can change it - see readline docs).
    #
    # Store the file in ~/.pystartup, and set an environment variable to point
    # to it:  "export PYTHONSTARTUP=~/.pystartup" in bash.

    import atexit
    import os
    import readline
    import rlcompleter

    historyPath = os.path.expanduser("~/.pyhistory")

    def save_history(historyPath=historyPath):
        import readline
        readline.write_history_file(historyPath)

    if os.path.exists(historyPath):
        readline.read_history_file(historyPath)

    atexit.register(save_history)
    del os, atexit, readline, rlcompleter, save_history, historyPath


  ---------- Footnotes ----------

  (1) Python will execute the contents of a file identified by the `PYTHONSTARTUP'
environment variable when you start an interactive interpreter.  To
customize Python even for non-interactive mode, see *note The
Customization Modules: 1b.


File: python-tutorial-3.2.2.info,  Node: Alternatives to the Interactive Interpreter,  Prev: Key Bindings,  Up: Interactive Input Editing and History Substitution

13.4 Alternatives to the Interactive Interpreter
================================================

This facility is an enormous step forward compared to earlier versions
of the interpreter; however, some wishes are left: It would be nice if
the proper indentation were suggested on continuation lines (the parser
knows if an indent token is required next).  The completion mechanism
might use the interpreter's symbol table.  A command to check (or even
suggest) matching parentheses, quotes, etc., would also be useful.

  One alternative enhanced interactive interpreter that has been around
for quite some time is IPython(1), which features tab completion,
object exploration and advanced history management.  It can also be
thoroughly customized and embedded into other applications.  Another
similar enhanced interactive environment is bpython(2).

  ---------- Footnotes ----------

  (1) http://ipython.scipy.org/

  (2) http://www.bpython-interpreter.org/


File: python-tutorial-3.2.2.info,  Node: Floating Point Arithmetic Issues and Limitations,  Next: Index,  Prev: Interactive Input Editing and History Substitution,  Up: Top

14 Floating Point Arithmetic:  Issues and Limitations
*****************************************************

Floating-point numbers are represented in computer hardware as base 2
(binary) fractions.  For example, the decimal fraction

    0.125

has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction

    0.001

has value 0/2 + 0/4 + 1/8.  These two fractions have identical values,
the only real difference being that the first is written in base 10
fractional notation, and the second in base 2.

  Unfortunately, most decimal fractions cannot be represented exactly
as binary fractions.  A consequence is that, in general, the decimal
floating-point numbers you enter are only approximated by the binary
floating-point numbers actually stored in the machine.

  The problem is easier to understand at first in base 10.  Consider
the fraction 1/3.  You can approximate that as a base 10 fraction:

    0.3

or, better,

    0.33

or, better,

    0.333

and so on.  No matter how many digits you're willing to write down, the
result will never be exactly 1/3, but will be an increasingly better
approximation of 1/3.

  In the same way, no matter how many base 2 digits you're willing to
use, the decimal value 0.1 cannot be represented exactly as a base 2
fraction.  In base 2, 1/10 is the infinitely repeating fraction

    0.0001100110011001100110011001100110011001100110011...

Stop at any finite number of bits, and you get an approximation.  On
most machines today, floats are approximated using a binary fraction
with the numerator using the first 53 bits starting with the most
significant bit and with the denominator as a power of two.  In the
case of 1/10, the binary fraction is `3602879701896397 / 2 ** 55' which
is close to but not exactly equal to the true value of 1/10.

  Many users are not aware of the approximation because of the way
values are displayed.  Python only prints a decimal approximation to
the true decimal value of the binary approximation stored by the
machine.  On most machines, if Python were to print the true decimal
value of the binary approximation stored for 0.1, it would have to
display

    >>> 0.1
    0.1000000000000000055511151231257827021181583404541015625

That is more digits than most people find useful, so Python keeps the
number of digits manageable by displaying a rounded value instead

    >>> 1 / 10
    0.1

Just remember, even though the printed result looks like the exact value
of 1/10, the actual stored value is the nearest representable binary
fraction.

  Interestingly, there are many different decimal numbers that share
the same nearest approximate binary fraction.  For example, the numbers
`0.1' and `0.10000000000000001' and
`0.1000000000000000055511151231257827021181583404541015625' are all
approximated by `3602879701896397 / 2 ** 55'.  Since all of these
decimal values share the same approximation, any one of them could be
displayed while still preserving the invariant `eval(repr(x)) == x'.

  Historically, the Python prompt and built-in `repr()' function would
choose the one with 17 significant digits, `0.10000000000000001'.
Starting with Python 3.1, Python (on most systems) is now able to
choose the shortest of these and simply display `0.1'.

  Note that this is in the very nature of binary floating-point: this
is not a bug in Python, and it is not a bug in your code either.
You'll see the same kind of thing in all languages that support your
hardware's floating-point arithmetic (although some languages may not
_display_ the difference by default, or in all output modes).

  For more pleasant output, you may may wish to use string formatting
to produce a limited number of significant digits:

    >>> format(math.pi, '.12g')  # give 12 significant digits
    '3.14159265359'

    >>> format(math.pi, '.2f')   # give 2 digits after the point
    '3.14'

    >>> repr(math.pi)
    '3.141592653589793'

It's important to realize that this is, in a real sense, an illusion:
you're simply rounding the _display_ of the true machine value.

  One illusion may beget another.  For example, since 0.1 is not
exactly 1/10, summing three values of 0.1 may not yield exactly 0.3,
either:

    >>> .1 + .1 + .1 == .3
    False

Also, since the 0.1 cannot get any closer to the exact value of 1/10 and
0.3 cannot get any closer to the exact value of 3/10, then pre-rounding
with `round()' function cannot help:

    >>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
    False

Though the numbers cannot be made closer to their intended exact values,
the `round()' function can be useful for post-rounding so that results
with inexact values become comparable to one another:

    >>> round(.1 + .1 + .1, 10) == round(.3, 10)
    True

Binary floating-point arithmetic holds many surprises like this.  The
problem with "0.1" is explained in precise detail below, in the
"Representation Error" section.  See The Perils of Floating Point(1)
for a more complete account of other common surprises.

  As that says near the end, "there are no easy answers."  Still, don't
be unduly wary of floating-point!  The errors in Python float
operations are inherited from the floating-point hardware, and on most
machines are on the order of no more than 1 part in 2**53 per
operation.  That's more than adequate for most tasks, but you do need
to keep in mind that it's not decimal arithmetic and that every float
operation can suffer a new rounding error.

  While pathological cases do exist, for most casual use of
floating-point arithmetic you'll see the result you expect in the end
if you simply round the display of your final results to the number of
decimal digits you expect.  `str()' usually suffices, and for finer
control see the `str.format()' method's format specifiers in
_formatstrings_.

  For use cases which require exact decimal representation, try using
the `decimal' module which implements decimal arithmetic suitable for
accounting applications and high-precision applications.

  Another form of exact arithmetic is supported by the `fractions'
module which implements arithmetic based on rational numbers (so the
numbers like 1/3 can be represented exactly).

  If you are a heavy user of floating point operations you should take
a look at the Numerical Python package and many other packages for
mathematical and statistical operations supplied by the SciPy project.
See <<http://scipy.org>>.

  Python provides tools that may help on those rare occasions when you
really _do_ want to know the exact value of a float.  The
`float.as_integer_ratio()' method expresses the value of a float as a
fraction:

    >>> x = 3.14159
    >>> x.as_integer_ratio()
    (3537115888337719, 1125899906842624)

Since the ratio is exact, it can be used to losslessly recreate the
original value:

    >>> x == 3537115888337719 / 1125899906842624
    True

The `float.hex()' method expresses a float in hexadecimal (base 16),
again giving the exact value stored by your computer:

    >>> x.hex()
    '0x1.921f9f01b866ep+1'

This precise hexadecimal representation can be used to reconstruct the
float value exactly:

    >>> x == float.fromhex('0x1.921f9f01b866ep+1')
    True

Since the representation is exact, it is useful for reliably porting
values across different versions of Python (platform independence) and
exchanging data with other languages that support the same format (such
as Java and C99).

  Another helpful tool is the `math.fsum()' function which helps
mitigate loss-of-precision during summation.  It tracks "lost digits"
as values are added onto a running total.  That can make a difference
in overall accuracy so that the errors do not accumulate to the point
where they affect the final total:

    >>> sum([0.1] * 10) == 1.0
    False
    >>> math.fsum([0.1] * 10) == 1.0
    True


* Menu:

* Representation Error::

  ---------- Footnotes ----------

  (1) http://www.lahey.com/float.htm


File: python-tutorial-3.2.2.info,  Node: Representation Error,  Up: Floating Point Arithmetic Issues and Limitations

14.1 Representation Error
=========================

This section explains the "0.1" example in detail, and shows how you
can perform an exact analysis of cases like this yourself.  Basic
familiarity with binary floating-point representation is assumed.

  _Representation error_ refers to the fact that some (most, actually)
decimal fractions cannot be represented exactly as binary (base 2)
fractions.  This is the chief reason why Python (or Perl, C, C++, Java,
Fortran, and many others) often won't display the exact decimal number
you expect.

  Why is that?  1/10 is not exactly representable as a binary fraction.
Almost all machines today (November 2000) use IEEE-754 floating point
arithmetic, and almost all platforms map Python floats to IEEE-754
"double precision".  754 doubles contain 53 bits of precision, so on
input the computer strives to convert 0.1 to the closest fraction it
can of the form _J_/2**_N_ where _J_ is an integer containing exactly
53 bits.  Rewriting

    1 / 10 ~= J / (2**N)

as

    J ~= 2**N / 10

and recalling that _J_ has exactly 53 bits (is `>= 2**52' but `<
2**53'), the best value for _N_ is 56:

    >>> 2**52 <=  2**56 // 10  < 2**53
    True

That is, 56 is the only value for _N_ that leaves _J_ with exactly 53
bits.  The best possible value for _J_ is then that quotient rounded:

    >>> q, r = divmod(2**56, 10)
    >>> r
    6

Since the remainder is more than half of 10, the best approximation is
obtained by rounding up:

    >>> q+1
    7205759403792794

Therefore the best possible approximation to 1/10 in 754 double
precision is:

    7205759403792794 / 2 ** 56

Dividing both the numerator and denominator by two reduces the fraction
to:

    3602879701896397 / 2 ** 55

Note that since we rounded up, this is actually a little bit larger
than 1/10; if we had not rounded up, the quotient would have been a
little bit smaller than 1/10.  But in no case can it be _exactly_ 1/10!

  So the computer never "sees" 1/10:  what it sees is the exact
fraction given above, the best 754 double approximation it can get:

    >>> 0.1 * 2 ** 55
    3602879701896397.0

If we multiply that fraction by 10**55, we can see the value out to 55
decimal digits:

    >>> 3602879701896397 * 10 ** 55 // 2 ** 55
    1000000000000000055511151231257827021181583404541015625

meaning that the exact number stored in the computer is equal to the
decimal value 0.1000000000000000055511151231257827021181583404541015625.
Instead of displaying the full decimal value, many languages (including
older versions of Python), round the result to 17 significant digits:

    >>> format(0.1, '.17f')
    '0.10000000000000001'

The `fractions' and `decimal' modules make these calculations easy:

    >>> from decimal import Decimal
    >>> from fractions import Fraction

    >>> Fraction.from_float(0.1)
    Fraction(3602879701896397, 36028797018963968)

    >>> (0.1).as_integer_ratio()
    (3602879701896397, 36028797018963968)

    >>> Decimal.from_float(0.1)
    Decimal('0.1000000000000000055511151231257827021181583404541015625')

    >>> format(Decimal.from_float(0.1), '.17')
    '0.10000000000000001'



File: python-tutorial-3.2.2.info,  Node: Index,  Prev: Floating Point Arithmetic Issues and Limitations,  Up: Top

Index
*****

 [index ]
* Menu:

* __all__:                               Importing * From a Package.
                                                               (line  6)
* built-in function; help:               Operating System Interface.
                                                               (line 20)
* built-in function; open:               Reading and Writing Files.
                                                               (line  6)
* coding; style:                         Intermezzo Coding Style.
                                                               (line  6)
* docstrings <1>:                        Defining Functions.   (line 21)
* docstrings:                            Documentation Strings.
                                                               (line  6)
* documentation strings <1>:             Defining Functions.   (line 21)
* documentation strings:                 Documentation Strings.
                                                               (line  6)
* environment variable; PATH <1>:        The Module Search Path.
                                                               (line  9)
* environment variable; PATH:            Executable Python Scripts.
                                                               (line 11)
* environment variable; PYTHONPATH <1>:  The Module Search Path.
                                                               (line 10)
* environment variable; PYTHONPATH <2>:  Standard Modules.     (line 34)
* environment variable; PYTHONPATH <3>:  The Module Search Path.
                                                               (line 16)
* environment variable; PYTHONPATH:      Standard Modules.     (line 33)
* environment variable; PYTHONSTARTUP <1>: Key Bindings.       (line 94)
* environment variable; PYTHONSTARTUP:   The Interactive Startup File.
                                                               (line  8)
* module; builtins:                      The dir Function.     (line 35)
* module; compileall:                    "Compiled" Python files.
                                                               (line 56)
* module; pickle:                        The pickle Module.    (line  6)
* module; readline:                      Key Bindings.         (line 43)
* module; rlcompleter:                   Key Bindings.         (line 43)
* module; search; path:                  The Module Search Path.
                                                               (line  6)
* module; sys:                           Standard Modules.     (line  6)
* object; file:                          Reading and Writing Files.
                                                               (line  6)
* object; method:                        Instance Objects.     (line 31)
* PATH <1>:                              Executable Python Scripts.
                                                               (line 11)
* PATH:                                  The Module Search Path.
                                                               (line  9)
* Python Enhancement Proposals; PEP 8:   Intermezzo Coding Style.
                                                               (line 13)
* PYTHONPATH <1>:                        Standard Modules.     (line 34)
* PYTHONPATH <2>:                        The Module Search Path.
                                                               (line  8)
* PYTHONPATH <3>:                        Standard Modules.     (line 33)
* PYTHONPATH:                            The Module Search Path.
                                                               (line 10)
* PYTHONSTARTUP <1>:                     Key Bindings.         (line 94)
* PYTHONSTARTUP:                         The Interactive Startup File.
                                                               (line  8)
* statement; *:                          Arbitrary Argument Lists.
                                                               (line  6)
* statement; **:                         Unpacking Argument Lists.
                                                               (line 19)
* statement; for:                        for Statements.       (line  6)
* strings, documentation <1>:            Documentation Strings.
                                                               (line  6)
* strings, documentation:                Defining Functions.   (line 21)



Tag Table:
Node: Top403
Ref: tutorial/index doc682
Ref: 0682
Node: Whetting Your Appetite3256
Ref: tutorial/appetite doc3382
Ref: 13382
Ref: tutorial/appetite tut-intro3382
Ref: 23382
Ref: tutorial/appetite the-python-tutorial3382
Ref: 33382
Ref: tutorial/appetite whetting-your-appetite3382
Ref: 43382
Ref: tutorial/appetite tutorial-index3382
Ref: 53382
Node: Using the Python Interpreter7894
Ref: tutorial/interpreter using-the-python-interpreter8051
Ref: 68051
Ref: tutorial/interpreter doc8051
Ref: 78051
Ref: tutorial/interpreter tut-using8051
Ref: 88051
Node: Invoking the Interpreter8437
Ref: tutorial/interpreter tut-invoking8585
Ref: 98585
Ref: tutorial/interpreter invoking-the-interpreter8585
Ref: a8585
Ref: Invoking the Interpreter-Footnote-111607
Node: Argument Passing11798
Ref: tutorial/interpreter argument-passing11915
Ref: c11915
Ref: tutorial/interpreter tut-argpassing11915
Ref: d11915
Node: Interactive Mode12738
Ref: tutorial/interpreter tut-interactive12855
Ref: e12855
Ref: tutorial/interpreter interactive-mode12855
Ref: f12855
Node: The Interpreter and Its Environment13797
Ref: tutorial/interpreter tut-interp13945
Ref: 1013945
Ref: tutorial/interpreter the-interpreter-and-its-environment13945
Ref: 1113945
Node: Error Handling14173
Ref: tutorial/interpreter tut-error14308
Ref: 1214308
Ref: tutorial/interpreter error-handling14308
Ref: 1314308
Ref: Error Handling-Footnote-115299
Node: Executable Python Scripts15364
Ref: tutorial/interpreter tut-scripts15528
Ref: 1415528
Ref: tutorial/interpreter executable-python-scripts15528
Ref: 1515528
Node: Source Code Encoding16561
Ref: tutorial/interpreter source-code-encoding16739
Ref: 1616739
Ref: tutorial/interpreter tut-source-encoding16739
Ref: 1716739
Node: The Interactive Startup File18088
Ref: tutorial/interpreter tut-startup18266
Ref: 1818266
Ref: tutorial/interpreter the-interactive-startup-file18266
Ref: 1918266
Node: The Customization Modules19597
Ref: tutorial/interpreter the-customization-modules19746
Ref: 1a19746
Ref: tutorial/interpreter tut-customize19746
Ref: 1b19746
Node: An Informal Introduction to Python20603
Ref: tutorial/introduction an-informal-introduction-to-python20761
Ref: 1c20761
Ref: tutorial/introduction tut-informal20761
Ref: 1d20761
Ref: tutorial/introduction doc20761
Ref: 1e20761
Node: Using Python as a Calculator22124
Ref: tutorial/introduction using-python-as-a-calculator22278
Ref: 1f22278
Ref: tutorial/introduction tut-calculator22278
Ref: 2022278
Node: Numbers22537
Ref: tutorial/introduction tut-numbers22640
Ref: 2122640
Ref: tutorial/introduction numbers22640
Ref: 2222640
Node: Strings26327
Ref: tutorial/introduction tut-strings26452
Ref: 2426452
Ref: tutorial/introduction strings26452
Ref: 2526452
Node: About Unicode33829
Ref: tutorial/introduction about-unicode33952
Ref: 2633952
Ref: tutorial/introduction tut-unicodestrings33952
Ref: 2733952
Node: Lists35685
Ref: tutorial/introduction tut-lists35792
Ref: 2835792
Ref: tutorial/introduction lists35792
Ref: 2935792
Node: First Steps Towards Programming38108
Ref: tutorial/introduction first-steps-towards-programming38262
Ref: 2a38262
Ref: tutorial/introduction tut-firststeps38262
Ref: 2b38262
Node: More Control Flow Tools41272
Ref: tutorial/controlflow tut-morecontrol41417
Ref: 2c41417
Ref: tutorial/controlflow doc41417
Ref: 2d41417
Ref: tutorial/controlflow more-control-flow-tools41417
Ref: 2e41417
Node: if Statements41946
Ref: tutorial/controlflow if-statements42057
Ref: 2f42057
Ref: tutorial/controlflow tut-if42057
Ref: 3042057
Node: for Statements42796
Ref: tutorial/controlflow tut-for42934
Ref: 3142934
Ref: tutorial/controlflow for-statements42934
Ref: 3242934
Node: The range Function44095
Ref: tutorial/controlflow the-range-function44275
Ref: 3344275
Ref: tutorial/controlflow tut-range44275
Ref: 3444275
Node: break and continue Statements and else Clauses on Loops46170
Ref: tutorial/controlflow break-and-continue-statements-and-else-clauses-on-loops46351
Ref: 3646351
Ref: tutorial/controlflow tut-break46351
Ref: 3746351
Node: pass Statements47600
Ref: tutorial/controlflow tut-pass47781
Ref: 3847781
Ref: tutorial/controlflow pass-statements47781
Ref: 3947781
Node: Defining Functions48467
Ref: tutorial/controlflow defining-functions48619
Ref: 3a48619
Ref: tutorial/controlflow tut-functions48619
Ref: 3b48619
Ref: Defining Functions-Footnote-153327
Node: More on Defining Functions53524
Ref: tutorial/controlflow tut-defining53684
Ref: 3e53684
Ref: tutorial/controlflow more-on-defining-functions53684
Ref: 3f53684
Node: Default Argument Values54033
Ref: tutorial/controlflow default-argument-values54160
Ref: 4054160
Ref: tutorial/controlflow tut-defaultargs54160
Ref: 4154160
Node: Keyword Arguments56108
Ref: tutorial/controlflow tut-keywordargs56268
Ref: 4256268
Ref: tutorial/controlflow keyword-arguments56268
Ref: 4356268
Node: Arbitrary Argument Lists59535
Ref: tutorial/controlflow tut-arbitraryargs59696
Ref: 4459696
Ref: tutorial/controlflow arbitrary-argument-lists59696
Ref: 4559696
Node: Unpacking Argument Lists60708
Ref: tutorial/controlflow tut-unpacking-arguments60864
Ref: 4760864
Ref: tutorial/controlflow unpacking-argument-lists60864
Ref: 4860864
Node: Lambda Forms62065
Ref: tutorial/controlflow tut-lambda62218
Ref: 4962218
Ref: tutorial/controlflow lambda-forms62218
Ref: 4a62218
Node: Documentation Strings62984
Ref: tutorial/controlflow tut-docstrings63104
Ref: 3c63104
Ref: tutorial/controlflow documentation-strings63104
Ref: 4b63104
Node: Intermezzo Coding Style65010
Ref: tutorial/controlflow intermezzo-coding-style65143
Ref: 4c65143
Ref: tutorial/controlflow tut-codingstyle65143
Ref: 4d65143
Ref: Intermezzo Coding Style-Footnote-167269
Node: Data Structures67316
Ref: tutorial/datastructures tut-structures67434
Ref: 4f67434
Ref: tutorial/datastructures data-structures67434
Ref: 5067434
Ref: tutorial/datastructures doc67434
Ref: 5167434
Node: More on Lists67896
Ref: tutorial/datastructures tut-morelists68002
Ref: 5268002
Ref: tutorial/datastructures more-on-lists68002
Ref: 5368002
Node: Using Lists as Stacks70198
Ref: tutorial/datastructures using-lists-as-stacks70314
Ref: 5470314
Ref: tutorial/datastructures tut-lists-as-stacks70314
Ref: 5570314
Node: Using Lists as Queues70918
Ref: tutorial/datastructures tut-lists-as-queues71062
Ref: 5671062
Ref: tutorial/datastructures using-lists-as-queues71062
Ref: 5771062
Node: List Comprehensions72101
Ref: tutorial/datastructures tut-listcomps72250
Ref: 5872250
Ref: tutorial/datastructures list-comprehensions72250
Ref: 5972250
Node: Nested List Comprehensions74388
Ref: tutorial/datastructures nested-list-comprehensions74507
Ref: 5a74507
Node: The del statement75759
Ref: tutorial/datastructures tut-del75894
Ref: 5b75894
Ref: tutorial/datastructures the-del-statement75894
Ref: 5c75894
Node: Tuples and Sequences76680
Ref: tutorial/datastructures tuples-and-sequences76806
Ref: 5d76806
Ref: tutorial/datastructures tut-tuples76806
Ref: 4676806
Node: Sets79200
Ref: tutorial/datastructures tut-sets79321
Ref: 5e79321
Ref: tutorial/datastructures sets79321
Ref: 5f79321
Node: Dictionaries80997
Ref: tutorial/datastructures tut-dictionaries81116
Ref: 6081116
Ref: tutorial/datastructures dictionaries81116
Ref: 6181116
Ref: Dictionaries-Footnote-183919
Node: Looping Techniques84132
Ref: tutorial/datastructures looping-techniques84265
Ref: 6284265
Ref: tutorial/datastructures tut-loopidioms84265
Ref: 3584265
Node: More on Conditions85906
Ref: tutorial/datastructures tut-conditions86062
Ref: 6386062
Ref: tutorial/datastructures more-on-conditions86062
Ref: 6486062
Node: Comparing Sequences and Other Types88039
Ref: tutorial/datastructures comparing-sequences-and-other-types88168
Ref: 6588168
Ref: tutorial/datastructures tut-comparing88168
Ref: 6688168
Node: Modules89715
Ref: tutorial/modules tut-modules89826
Ref: 6789826
Ref: tutorial/modules modules89826
Ref: 6889826
Ref: tutorial/modules doc89826
Ref: 6989826
Node: More on Modules92535
Ref: tutorial/modules more-on-modules92634
Ref: 6a92634
Ref: tutorial/modules tut-moremodules92634
Ref: 6b92634
Ref: More on Modules-Footnote-195025
Node: Executing modules as scripts95207
Ref: tutorial/modules tut-modulesasscripts95333
Ref: 6c95333
Ref: tutorial/modules executing-modules-as-scripts95333
Ref: 6d95333
Node: The Module Search Path96195
Ref: tutorial/modules the-module-search-path96353
Ref: 6e96353
Ref: tutorial/modules tut-searchpath96353
Ref: 6f96353
Node: "Compiled" Python files97605
Ref: tutorial/modules compiled-python-files97726
Ref: 7197726
Node: Standard Modules100564
Ref: tutorial/modules standard-modules100688
Ref: 72100688
Ref: tutorial/modules tut-standardmodules100688
Ref: 70100688
Node: The dir Function102081
Ref: tutorial/modules tut-dir102198
Ref: 73102198
Ref: tutorial/modules the-dir-function102198
Ref: 74102198
Node: Packages105376
Ref: tutorial/modules packages105468
Ref: 75105468
Ref: tutorial/modules tut-packages105468
Ref: 76105468
Node: Importing * From a Package109675
Ref: tutorial/modules tut-pkg-import-star109794
Ref: 77109794
Ref: tutorial/modules importing-from-a-package109794
Ref: 78109794
Node: Intra-package References112334
Ref: tutorial/modules intra-package-references112494
Ref: 79112494
Node: Packages in Multiple Directories113470
Ref: tutorial/modules packages-in-multiple-directories113595
Ref: 7a113595
Node: Input and Output114106
Ref: tutorial/inputoutput tut-io114223
Ref: 7b114223
Ref: tutorial/inputoutput doc114223
Ref: 7c114223
Ref: tutorial/inputoutput input-and-output114223
Ref: 7d114223
Node: Fancier Output Formatting114660
Ref: tutorial/inputoutput fancier-output-formatting114787
Ref: 7e114787
Ref: tutorial/inputoutput tut-formatting114787
Ref: 7f114787
Node: Old string formatting122130
Ref: tutorial/inputoutput old-string-formatting122228
Ref: 80122228
Node: Reading and Writing Files122958
Ref: tutorial/inputoutput reading-and-writing-files123085
Ref: 81123085
Ref: tutorial/inputoutput tut-files123085
Ref: 82123085
Node: Methods of File Objects124657
Ref: tutorial/inputoutput methods-of-file-objects124783
Ref: 83124783
Ref: tutorial/inputoutput tut-filemethods124783
Ref: 84124783
Node: The pickle Module129306
Ref: tutorial/inputoutput tut-pickle129432
Ref: 85129432
Ref: tutorial/inputoutput the-pickle-module129432
Ref: 86129432
Node: Errors and Exceptions131339
Ref: tutorial/errors errors-and-exceptions131456
Ref: 87131456
Ref: tutorial/errors doc131456
Ref: 88131456
Ref: tutorial/errors tut-errors131456
Ref: 89131456
Node: Syntax Errors131906
Ref: tutorial/errors tut-syntaxerrors132011
Ref: 8a132011
Ref: tutorial/errors syntax-errors132011
Ref: 8b132011
Node: Exceptions132795
Ref: tutorial/errors exceptions132928
Ref: 8c132928
Ref: tutorial/errors tut-exceptions132928
Ref: 8d132928
Node: Handling Exceptions134700
Ref: tutorial/errors handling-exceptions134838
Ref: 8e134838
Ref: tutorial/errors tut-handling134838
Ref: 8f134838
Node: Raising Exceptions139756
Ref: tutorial/errors tut-raising139907
Ref: 90139907
Ref: tutorial/errors raising-exceptions139907
Ref: 91139907
Node: User-defined Exceptions140800
Ref: tutorial/errors tut-userexceptions140957
Ref: 92140957
Ref: tutorial/errors user-defined-exceptions140957
Ref: 93140957
Node: Defining Clean-up Actions143676
Ref: tutorial/errors defining-clean-up-actions143842
Ref: 94143842
Ref: tutorial/errors tut-cleanup143842
Ref: 95143842
Node: Predefined Clean-up Actions145889
Ref: tutorial/errors tut-cleanup-with146023
Ref: 96146023
Ref: tutorial/errors predefined-clean-up-actions146023
Ref: 97146023
Node: Classes147104
Ref: tutorial/classes classes147239
Ref: 98147239
Ref: tutorial/classes doc147239
Ref: 99147239
Ref: tutorial/classes tut-classes147239
Ref: 3d147239
Node: A Word About Names and Objects149234
Ref: tutorial/classes a-word-about-names-and-objects149360
Ref: 9b149360
Ref: tutorial/classes tut-object149360
Ref: 9c149360
Node: Python Scopes and Namespaces150277
Ref: tutorial/classes tut-scopes150435
Ref: 9d150435
Ref: tutorial/classes python-scopes-and-namespaces150435
Ref: 9e150435
Ref: Python Scopes and Namespaces-Footnote-1156347
Node: Scopes and Namespaces Example156714
Ref: tutorial/classes scopes-and-namespaces-example156823
Ref: 9f156823
Ref: tutorial/classes tut-scopeexample156823
Ref: a0156823
Node: A First Look at Classes158103
Ref: tutorial/classes tut-firstclasses158245
Ref: 4e158245
Ref: tutorial/classes a-first-look-at-classes158245
Ref: a1158245
Node: Class Definition Syntax158493
Ref: tutorial/classes tut-classdefinition158613
Ref: a2158613
Ref: tutorial/classes class-definition-syntax158613
Ref: a3158613
Node: Class Objects160114
Ref: tutorial/classes class-objects160259
Ref: a4160259
Ref: tutorial/classes tut-classobjects160259
Ref: a5160259
Node: Instance Objects162361
Ref: tutorial/classes tut-instanceobjects162497
Ref: a6162497
Ref: tutorial/classes instance-objects162497
Ref: a7162497
Node: Method Objects164105
Ref: tutorial/classes tut-methodobjects164219
Ref: a8164219
Ref: tutorial/classes method-objects164219
Ref: a9164219
Node: Random Remarks166102
Ref: tutorial/classes random-remarks166227
Ref: aa166227
Ref: tutorial/classes tut-remarks166227
Ref: ab166227
Node: Inheritance170043
Ref: tutorial/classes tut-inheritance170162
Ref: ac170162
Ref: tutorial/classes inheritance170162
Ref: ad170162
Node: Multiple Inheritance172790
Ref: tutorial/classes tut-multiple172873
Ref: ae172873
Ref: tutorial/classes multiple-inheritance172873
Ref: af172873
Node: Private Variables174819
Ref: tutorial/classes tut-private174937
Ref: 9a174937
Ref: tutorial/classes private-variables174937
Ref: b0174937
Node: Odds and Ends177297
Ref: tutorial/classes odds-and-ends177430
Ref: b1177430
Ref: tutorial/classes tut-odds177430
Ref: b2177430
Node: Exceptions Are Classes Too178397
Ref: tutorial/classes tut-exceptionclasses178522
Ref: b3178522
Ref: tutorial/classes exceptions-are-classes-too178522
Ref: b4178522
Node: Iterators179916
Ref: tutorial/classes iterators180038
Ref: b5180038
Ref: tutorial/classes tut-iterators180038
Ref: b6180038
Node: Generators182135
Ref: tutorial/classes tut-generators182252
Ref: b7182252
Ref: tutorial/classes generators182252
Ref: b8182252
Node: Generator Expressions183614
Ref: tutorial/classes generator-expressions183713
Ref: b9183713
Ref: tutorial/classes tut-genexps183713
Ref: ba183713
Node: Brief Tour of the Standard Library184778
Ref: tutorial/stdlib brief-tour-of-the-standard-library184937
Ref: bb184937
Ref: tutorial/stdlib tut-brieftour184937
Ref: bc184937
Ref: tutorial/stdlib doc184937
Ref: bd184937
Node: Operating System Interface185330
Ref: tutorial/stdlib tut-os-interface185465
Ref: be185465
Ref: tutorial/stdlib operating-system-interface185465
Ref: bf185465
Node: File Wildcards186604
Ref: tutorial/stdlib tut-file-wildcards186770
Ref: c0186770
Ref: tutorial/stdlib file-wildcards186770
Ref: c1186770
Node: Command Line Arguments186997
Ref: tutorial/stdlib tut-command-line-arguments187185
Ref: c2187185
Ref: tutorial/stdlib command-line-arguments187185
Ref: c3187185
Node: Error Output Redirection and Program Termination187767
Ref: tutorial/stdlib tut-stderr187964
Ref: c4187964
Ref: tutorial/stdlib error-output-redirection-and-program-termination187964
Ref: c5187964
Node: String Pattern Matching188468
Ref: tutorial/stdlib tut-string-pattern-matching188654
Ref: c6188654
Ref: tutorial/stdlib string-pattern-matching188654
Ref: c7188654
Node: Mathematics189273
Ref: tutorial/stdlib mathematics189426
Ref: c8189426
Ref: tutorial/stdlib tut-mathematics189426
Ref: c9189426
Node: Internet Access190164
Ref: tutorial/stdlib internet-access190309
Ref: ca190309
Ref: tutorial/stdlib tut-internet-access190309
Ref: cb190309
Node: Dates and Times191241
Ref: tutorial/stdlib dates-and-times191391
Ref: cc191391
Ref: tutorial/stdlib tut-dates-and-times191391
Ref: cd191391
Node: Data Compression192187
Ref: tutorial/stdlib tut-data-compression192345
Ref: ce192345
Ref: tutorial/stdlib data-compression192345
Ref: cf192345
Node: Performance Measurement192794
Ref: tutorial/stdlib performance-measurement192952
Ref: d0192952
Ref: tutorial/stdlib tut-performance-measurement192952
Ref: d1192952
Node: Quality Control193778
Ref: tutorial/stdlib tut-quality-control193938
Ref: d2193938
Ref: tutorial/stdlib quality-control193938
Ref: d3193938
Node: Batteries Included195414
Ref: tutorial/stdlib tut-batteries-included195542
Ref: d4195542
Ref: tutorial/stdlib batteries-included195542
Ref: d5195542
Node: Brief Tour of the Standard Library -- Part II196826
Ref: tutorial/stdlib2 tut-brieftourtwo196987
Ref: d6196987
Ref: tutorial/stdlib2 brief-tour-of-the-standard-library-part-ii196987
Ref: d7196987
Ref: tutorial/stdlib2 doc196987
Ref: d8196987
Node: Output Formatting197436
Ref: tutorial/stdlib2 output-formatting197569
Ref: d9197569
Ref: tutorial/stdlib2 tut-output-formatting197569
Ref: da197569
Node: Templating199598
Ref: tutorial/stdlib2 tut-templating199779
Ref: db199779
Ref: tutorial/stdlib2 templating199779
Ref: dc199779
Node: Working with Binary Data Record Layouts202243
Ref: tutorial/stdlib2 working-with-binary-data-record-layouts202422
Ref: dd202422
Ref: tutorial/stdlib2 tut-binary-formats202422
Ref: de202422
Node: Multi-threading203507
Ref: tutorial/stdlib2 tut-multi-threading203683
Ref: df203683
Ref: tutorial/stdlib2 multi-threading203683
Ref: e0203683
Node: Logging205580
Ref: tutorial/stdlib2 tut-logging205732
Ref: e1205732
Ref: tutorial/stdlib2 logging205732
Ref: e2205732
Node: Weak References206855
Ref: tutorial/stdlib2 weak-references207020
Ref: e3207020
Ref: tutorial/stdlib2 tut-weak-references207020
Ref: e4207020
Node: Tools for Working with Lists208741
Ref: tutorial/stdlib2 tut-list-tools208932
Ref: e5208932
Ref: tutorial/stdlib2 tools-for-working-with-lists208932
Ref: e6208932
Node: Decimal Floating Point Arithmetic211296
Ref: tutorial/stdlib2 decimal-floating-point-arithmetic211463
Ref: e7211463
Ref: tutorial/stdlib2 tut-decimal-fp211463
Ref: e8211463
Node: What Now?213286
Ref: tutorial/whatnow doc213463
Ref: e9213463
Ref: tutorial/whatnow tut-whatnow213463
Ref: ea213463
Ref: tutorial/whatnow what-now213463
Ref: eb213463
Ref: What Now?-Footnote-1216792
Node: Interactive Input Editing and History Substitution216830
Ref: tutorial/interactive tut-interacting217010
Ref: b217010
Ref: tutorial/interactive doc217010
Ref: ec217010
Ref: tutorial/interactive interactive-input-editing-and-history-substitution217010
Ref: ed217010
Ref: Interactive Input Editing and History Substitution-Footnote-1218082
Node: Line Editing218141
Ref: tutorial/interactive tut-lineediting218284
Ref: ee218284
Ref: tutorial/interactive line-editing218284
Ref: ef218284
Node: History Substitution218982
Ref: tutorial/interactive tut-history219146
Ref: f0219146
Ref: tutorial/interactive history-substitution219146
Ref: f1219146
Node: Key Bindings219738
Ref: tutorial/interactive key-bindings219933
Ref: f2219933
Ref: tutorial/interactive tut-keybindings219933
Ref: f3219933
Ref: Key Bindings-Footnote-1222964
Node: Alternatives to the Interactive Interpreter223205
Ref: tutorial/interactive alternatives-to-the-interactive-interpreter223371
Ref: f4223371
Ref: tutorial/interactive tut-commentary223371
Ref: f5223371
Ref: Alternatives to the Interactive Interpreter-Footnote-1224260
Ref: Alternatives to the Interactive Interpreter-Footnote-2224293
Node: Floating Point Arithmetic Issues and Limitations224336
Ref: tutorial/floatingpoint floating-point-arithmetic-issues-and-limitations224512
Ref: f6224512
Ref: tutorial/floatingpoint tut-fp-issues224512
Ref: 23224512
Ref: tutorial/floatingpoint doc224512
Ref: f7224512
Ref: tutorial/floatingpoint bpython224512
Ref: f8224512
Ref: Floating Point Arithmetic Issues and Limitations-Footnote-1232410
Node: Representation Error232448
Ref: tutorial/floatingpoint tut-fp-error232568
Ref: f9232568
Ref: tutorial/floatingpoint representation-error232568
Ref: fa232568
Node: Index235711

End Tag Table


Local Variables:
coding: utf-8
End:
